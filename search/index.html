<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  

  <link href="/blog/css/franklin.css" rel="stylesheet">
<link href="/blog/css/global.css" rel="stylesheet">
<!-- <script src="/blog/libs/jquery/jquery.min.js"></script> -->

<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ¦¦</text></svg>">


  <title>Search</title>
</head>
<body>
<nav class="flex-container blog-nav">
  <!-- type-a have a fixed width which never changes -->
  <!-- type-b will grow up to a point -->
  <!-- type-c start at 0 and absorb remaining space-->
  <!-- https://jsfiddle.net/dehsq3jb/ -->
  <div class="type-c"></div>
  <div class="type-b link-spacer"></div>
  <div class="type-a logo"><a href="https://www.jasoneveleth.com">Jason's</a> <a href="https://www.jasoneveleth.com/blog">Blog</a></div>

  <div class="type-b content-spacer"></div>

  <div class="type-a nav-link"><a href="/blog/search">Search</a></div>
  <div class="type-b link-spacer"></div>
  <div class="type-c"></div>
</nav>

<main id="panel">

<h1 class="post-title">Search</h1>
<!-- <hr> -->
<!-- Content appended here -->
<div class="franklin-content">
<script>
const mystuff = [
{title: "Wave equation simulation", content: " # Inspiration  Imagine your worst enemy is playing a constant frequency in the center of her room. You're allowed to put speakers (which don't take up space) wherever you want in the room. The question is, what's the best place to put them and what should they play?  To be fair, this is not the question that I'll be answering in this post, but it was the inspiration. We first simplify the problem into 2D so your enemy is now vibrating a surface with constant frequency. To simulate this problem, we need to solve the wave equation, which I do in this post.  At first, I tried to figure out the finite difference equations, but I got stuck. Then, I looked it up and I found [this wonderful blog post](https://beltoforion.de/en/recreational_mathematics/2d-wave-equation.php). I've rederived the equations to make sure I believed it and I wrote the code in Julia, which you can find it on [GitHub](). My first attempt at figuring out the finite differences is in the Python notebook, and the final code is in `simulation.jl`.  # In action   <video controls src=\"/assets/wave-equation.mov\" alt=\"\"></video>   # The rederivation  See [calculus notation](/404) for notation. The wave equation is  $$D_{tt}u = c^2 ( D_{xx}u + D_{yy}u)$$  First, we figure out what the finite difference wave equation looks like. Since we have a second time derivative, we need to keep 2 past states to calculate the difference in the first derivative. Look at this picture ($u_{0,i,j}$ is the newest state)  ![Mode of action of the discretized version of the differential operator for the solution of the wave equation](https://beltoforion.de/en/recreational_mathematics/images/diskretisierung_wellengleichung.webp)  Let's do the time derivative first. $$D_tu_{1,i,j} = \\frac{\\Delta_t u_{1,i,j}}{dt} = \\frac{u_{1,i,j} - u_{2, i, j}}{dt}$$ So, $$D_{tt}u_{1,i,j} = \\frac{\\Delta_t D_t u_{1,i,j}}{dt}=\\frac{\\frac{u_{0,i,j} - u_{1, i, j}}{dt}-\\frac{u_{1,i,j} - u_{2, i, j}}{dt}}{dt} = \\frac{u_{0,i,j}-2u_{1,i,j}+u_{2,i,j}}{(dt)^2}$$ Next, we do space derivatives (ignoring $c^2$ for now), $$ \\begin{align*} D_{xx}u_{1,i,j} &+ D_{yy}u_{1,i,j} = \\frac{\\Delta_x D_x u_{1,i,j}}{dx} + \\frac{\\Delta_y D_y u_{1,i,j}}{dy}\\\\ &= \\frac{u_{1,i-1,j} - 2u_{1,i,j} + u_{1,i+1,j}}{(dx)^2} + \\frac{u_{1,i,j-1} - 2u_{1,i,j} + u_{1,i,j+1}}{(dy)^2} \\end{align*}$$  Returning to the wave equation, $$ \\begin{align*} D_{tt}u &= c^2 ( D_{xx}u + D_{yy}u)\\\\ \\frac{u_{0,i,j}-2u_{1,i,j}+u_{2,i,j}}{(dt)^2} &= c^2\\left(\\frac{u_{1,i-1,j} - 2u_{1,i,j} + u_{1,i+1,j}}{(dx)^2} + \\frac{u_{1,i,j-1} - 2u_{1,i,j} + u_{1,i,j+1}}{(dy)^2}\\right)\\\\ u_{0,i,j} &= 2u_{1,i,j} - u_{2,i,j} +c^2 (dt)^2\\left( \\frac{u_{1,i-1,j} - 2u_{1,i,j} + u_{1,i+1,j}}{(dx)^2} + \\frac{u_{1,i,j-1} - 2u_{1,i,j} + u_{1,i,j+1}}{(dy)^2}\\right) \\end{align*} $$  If we assume $dx = dy$ and $\\alpha = \\frac{c^2 (dt)^2}{(dx)^2}$ then $$u_{0,i,j} = 2u_{1,i,j} - u_{2,i,j} +\\alpha\\left( u_{1,i-1,j}+u_{1,i,j-1} - 4u_{1,i,j} + u_{1,i+1,j} + u_{1,i,j+1}\\right)$$ There are no $u_{0,\\_,\\_}$ on the RHS. Thus, every value in the newest level can be calculated by the ones in previous levels.  We deal with the boundary by only calculating `u[0,1:lx,1:ly]`, and leaving the rest 0. So shifts are calculated like so: `u[1,0:lx-2,1:ly]`.  Note: this is actually [Verlet integration](https://en.wikipedia.org/wiki/Verlet_integration) (a trick for solving for the next state in terms of the finite differences and the second derivatives).  ## Implementation details  We can play a frequency by resetting the value of a $u_{0,i,j}$ after the step to the value of a sine wave at the time. We can make a water droplet by setting part of the $u_{0,i,j}$ layer to a negative gaussian at a certain time step. This is achieved with `put_drop!()` and `play_noise!()` functions.  {{ addcomments }} "},
{title: "hashfs", content: " This weekend I was helping my aunt make sure that her files were syncing correctly between two laptops. I'd been thinking about git a lot, and I realized recursive hashing was the way to go.  The problem I was trying to solve was making comparisons between two directory trees easy. The solution I came up with was to use the sha256 digest of file contents to represent files. This prevents us from having to look at the file contents, and the comparison between two files is easy since the digests are just numbers. We can use the hash of all the files in the directory to represent a directory. So, to compare if two directories are identical, we just need to look at the digests that represent them. This solves the problem because now it is easy to see which parts of a directory tree are the same.  It remains to figure out how to display this information. I've been working with HTML a lot recently working on this blog, and I realized a `<details>` element is the perfect fit. It hides the contents unless you click on it, so you don't need to look at the files which have the same hashes. And, we can nest `<details>` elements to create a tree that mirrors the directory structure.  I choose to write this up in Rust since I love Rust. The code can be found on [github](https://github.com/jasoneveleth/hashfs).  This utility ended up not being useful since iCloud automatically frees up space by replacing files with a `file.ext.icloud` file, which ruins the whole hashing system. Regardless, I am very proud of it, and I think it could be useful to others.  # In action  For a directory tree like:  b |- a.txt |- b.txt |- c.txt |- d.txt |- e.txt |- f.txt |- g.txt |- j.txt  It would produce this (hashes have been elided for space):  <details class=\"d\"><summary class=\"s\"> <strong>b</strong> 7a9b89fa674b0b703eaafca2e79e474a55... </summary> <strong>a.txt</strong> 86bfc753650b4b730b7177b9e665dbe100...</br> <strong>b.txt</strong> 86bfc753650b4b730b7177b9e665dbe100...</br> <strong>c.txt</strong> a380d5f755183c7c0f05a327e7094c9e98...</br> <strong>d.txt</strong> a380d5f755183c7c0f05a327e7094c9e98...</br> <strong>e.txt</strong> 5c836f02b0d2653274fefab5e108d3e78c...</br> <strong>f.txt</strong> ecef6bf3c9100c87aaeb4fae46b23f23d6...</br> <strong>g.txt</strong> 9d1af65406716fd984b640f7f24b43ccd6...</br> <strong>j.txt</strong> 79a2f595545dd08b508c2a808e543befcb...</br> </details><style>:root{--l: 25px}details > details{margin-left: var(--l);}.s{margin-left: calc(0px - var(--l))}.d{font-family: monospace;margin-left: var(--l);font-size: 70%;}details > strong{font-weight: 700;}</style>    {{ addcomments }} "},
{title: "Colorspace in glium", content: " I have been working on a small project to learn [OpenGL](/404). I decided to use Rust since it is the best programming language ever conceived by man. The obvious choice for an OpenGL project in Rust is to use [`glium`](https://github.com/glium/glium/). However, I found their API a little confusing. I thought it would be useful to have a guide on how to deal with colorspaces in `glium` and OpenGL. This is that guide. **Note: This is my first foray into graphics, if anything is wrong, or hints at a misunderstanding on my part, please let me know.**  # Concepts involved  - `GL_FRAMEBUFFER_SRGB`: A global parameter, associated with an OpenGL context. It comes up so much, I will refer to it as `GFS`. How it affects gamma correction is explained in the [Summary of literature](/2023/07/31/understanding-GLFRAMEBUFFERSRGB-in-glium/#summary_of_literature). - Texture: a place to store image data/raster graphics (pixel values)     - can come in 2 variants: regular and sRGB     - can be used as a render target (in which case the texture will be attached on an FBO, mentioned below) or as a source of image data - Framebuffer: a collection of buffers used as a destination for rendering. Can be the Default Framebuffer or a user-created Framebuffer Object (FBO).  # \"help my colors are broken\" flowchart (for the current glium way)  Many of the issues people have encountered would be solved by this flow chart, so I've included it before the rest of my learnings.  ![](/assets/help-colors.jpg)  # Summary of literature  Normally, color values in images are assumed to be in linear color space. If an image is in sRGB color format (ie. `SrgbTexture2d` vs `Texture2d`), values are assumed to be stored in sRGB.  \"When fetching from sRGB images in shaders, values are converted from sRGB into linear colorspace.\" Thus, the shader only sees linear values.  If OpenGL needs to filter sampled values, the implementation is allowed to filter before or after the sRGB conversion (and since filtering is linear, you want it to happen in a linear space (ie. linear RGB)).  [source](https://www.khronos.org/opengl/wiki/Image_Format)  \"Normally, sRGB images perform color correction, such that texture reads from them will always convert to linear [RGB]\".  When writing from a fragment shader, we need to know how to interpret the values written by the shader. If the output buffer is linear RGB, we assume the answer is linear. But if we're writing to an sRGB image, maybe we want to write linear or sRGB. For this, we need a global toggle since the gamma correction partly depends on the output buffer. This is the `GFS` parameter.  When `GFS` is: - disabled: assume the output buffer is the same color space as input buffer (we assume the user knows what they're doing) - enabled: if destination is[^2] 	- sRGB: assume shader output is linear, so it converts linear RGB to sRGB 	- non-sRGB: no conversion  [^2]: you can check this with `glGetFramebufferAttachmentParameter(GL_Framebuffer_SRGB)`  Blending is a linear operation, so we need to convert to linear, then back to sRGB. If `GFS` is enabled, if a destination image is sRGB, the color will be converted to linear, blended w/ linear source and convert back. If `GFS` is disabled, \"we assume the user knows what they are doing\"; thus, \"blending against an sRGB image will not perform any correction. This is usually not a good idea even if you are writing sRGB color values from the Fragment Shader.\"  [source](https://www.khronos.org/opengl/wiki/Framebuffer)  This entire section is summarized by this graphic:  ![](/assets/gpu-colorspace.jpg)  # `clear_color()` vs `clear_color_srgb()`  If you call `clear_color_srgb()`, we enable `GFS` and record that in the global context if it wasn't already enabled. If you call `clear_color()`, we disable `GFS`  (and record that in the global context) if it wasn't already.  source: (`commit:filename:line-number)` `5d50e70:src/ops/clear.rs:38`  # Github Issues  - `#2059`: my issue, which this post hopefully addresses - `#1466`: requests a feature for `SrgbTexture2d` that `Texture2d` has - `#1414`: a misunderstanding - `#1185`: glutin issue - `#987`: created the `clear_color`â€“`clear_color_srgb` distinction  ## Issue `#1793`  - Setting `srgb=true` in `ContextBuilder` fixes the problem - claim: textures have sRGB and non-sRGB variants, so global context is not important  ## Issue `#1615`  - fix the problem with `program!()` macro in `src/macros.rs` using `let ___outputs_srgb: bool=false` - both variants of the `ProgramCreationInput` enum have `outputs_srgb` flags, and you can pass one of them to `Program::new()` to have direct control if you're not using `program!()` *(this is what I ended up fixing `#2059`, my issue, but I didn't understand it at the time)*  ## Issue `#805`  - some systems don't support `GFS` well, so it needs to be able to be disabled - rendering your image to an `SrgbTexture2d` instead of `Texture2d` fixes the problem - fix: a flag is available to `Program::new()` to turn it on and off *the same solution as `#1615` and `#2059` (mine)*  # What should we do?  We can either hide the fact that OpenGL uses `GFS`, or we should be very transparent about what `GFS` means and how to interact with it.  ## Transparent Approach  Here, `GFS` should be enabled or disabled when the context is initialized and never changed (there is already support for this in `ContextBuilder`). Using `clear_color()` to change the `GFS` value seems like the wrong way to go since it introduces unnecessary complexity. I can't think of a use case where being able to change `GFS` at runtime is useful if we're trying to be transparent (feel free to point one out in the comments).  In this approach with `GFS` enabled, we still require users to use `SrgbTexture`s and `Texture`s, and to differentiate what type of values are stored there. But, there is no need to specify whether a program outputs sRGB, since we are going to use OpenGL's underlying implicit conversions.  In this approach, if you choose to disable `GFS`:  - you should do everything using linear RGB and no gamma correction will be applied (except from `SrgbTexture`, which will of course be converted to linear when sampled from) - we assume the user understands what they are doing  ### How to implement this approach  First, remove `clear_color_srgb()` and don't fiddle with `GFS` in `clear_color()`. Second, remove the code which enables `GFS` in `use_program()` at `5d50e70:src/program/program.rs:449`.  ### Advantages of this approach  - familiarity: it respects the OpenGL model (using `GFS` as a global parameter) and obeys the [principle of least astonishment](https://en.wikipedia.org/wiki/Principle_of_least_astonishment)  - easy-of-use for beginners assuming they already understand OpenGL  ### Disadvantages  - blending with an sRGB image won't work nicely with `GFS` disabled, so all data must be in linear color space, which is mildly inconvenient  ## Hidden approach  The user should never have to worry about `GFS`. This is most similar to how things are done now. They do still need to worry about whether their textures and programs contain/output sRGB values.  ### How to implement this approach  We shouldn't let users choose the `GFS` setting when initializing a context since they shouldn't worry about it. And `GFS` should always be enabled. We will still need users to tell us whether they're texture has linear or sRGB values, and whether their program outputs linear or sRGB. But, that is the only time they'll need to worry about colorspace, we'll handle the enabling/disabling of `GFS` behind the scenes (similar to how we do it in `use_program()` at `5d50e70:src/program/program.rs:449`).  We also should remove `clear_color_srgb()` since users shouldn't worry about `GFS`.  ### Advantage of this approach  - simplicity: there's only 1 mode to worry about - backward compatibility with old `glium` programs since this is doesn't change the fundamental model  {{ addcomments }} "},
{title: "Voronoi Diagrams", content: " Imagine a city map that colored each house differently based on the nearest post office. That map would partition the city into colored regions, which approximate a Voronoi diagram, a concept that often appears in science and engineering. These diagrams appear in the network of crystals in heated metal; the bubbles in soap foams; and disease outbreaks originating from different sources.  ![](/assets/Euclidean_Voronoi_diagram.svg.png)  Motivated by Voronoi diagrams in the study of soap foams, I (along with my mentors at NIST) investigated the evolution of these diagrams over time. The potential energy of substances in a Voronoi format is often the surface area (or in the 2D case, perimeter). Thus, these diagrams often evolve by minimizing the total length of the boundaries of the regions (referred to as the perimeter). However, the problem becomes further complicated by requiring that none of the regions shrink and disappear, which often happens when this type of evolution is unconstrained. We can generalize the post office locations (the metaphor introduced in the first paragraph) as a collection of coordinates (referred to as sites). We are interested in an objective function whose input is the sites and whose value is the length of the perimeter of the diagram summed with an optional repulsion term, which keeps the sites from getting too close. This function is differentiable, so we can use many gradient descent methods to carry out the evolution. Interestingly, these different methods have different behavior. For example, using constant step-size gradient descent gives different behavior than using the Barzilai-Borwein method.  The objective function is highly nonlinear and nonconvex, so different methods and initial conditions yield different solutions. For each of these methods, we collect geometrical and topological statistics about the boundary network over time. Our goal is to understand how these diagrams change over time. Overall, it is important to understand the evolution of Voronoi diagrams because of the implications in metallurgy and the study of soap foams.  The source for this project can be found on [github](https://github.com/jasoneveleth/voronoi2).  {{ addcomments }} "},
{title: "Confetti", content: " # Overview  I took computer vision many years ago, and I wanted to refresh my knowledge of camera matrices and rendering. So I created [this website](https://www.jasoneveleth.com/confetti) that displays an infinite stream of confetti. It calculates the movement of confetti in real-time. The code can be found [here](https://github.com/jasoneveleth/confetti).  # Design  I wanted physics and camera matrices to be the focus of the project, so the UI is spartan.  To describe what is happening, we will assume that in the world, $x,y,z$ are arranged as if we're looking at an $x$-$y$ graph, and $z$ is coming toward us:  ![](/assets/axes.png)  We need to convert a point in that, to a point on the screen, which has coordinates $(0,0)$ in the top left, and increasing $x$ and $y$ going down and right. We can do that using `Rt`, which is the extrinsic matrix: $$[R\\mid t]=\\begin{bmatrix}1&0&0&t_x\\\\ 0&1&0&t_y\\\\ 0&0&1&t_z\\end{bmatrix}.$$ This matrix describes how the camera is positioned in relation to the origin. Our rotation is the identity, and our translation is $10$ in the $z$ direction (since our camera is oriented normally at $(0,0,-10)$). Thus, $t_x=t_y=0,t_z=10$. Left multiplying this matrix with a vector will move it 10 units in the $z$ direction (bringing the camera to the origin).  The second matrix we need is the intrinsic matrix: $$K=\\begin{bmatrix}f_x&s&u\\\\ 0&f_x&v\\\\ 0&0&s\\end{bmatrix}.$$ $f_x, f_y$ are the focal length in pixels of the camera. $u,v$ are the principle point offset (shift in the sensor inside the camera). $s$ is skew. For us, $f_x=f_y=\\max(w, h)/2$, which is the maximum of the width and height of the screen. Our skew is 1, and our principle point offsets are 0.  The `index.js` file holds most of the code, and `math.js` has some utility functions (like matrix multiplication). There is one function I want to highlight in `math.js`, and that is `world2image`. It converts world coordinates to image coordinates. It multiplies $K \\cdot [R\\mid t] \\cdot c$, where $c$ is the world coordinates and rescales the $x,y$ values by $z$. The `KRt` matrix is a precomputed multiplication of the intrinsic and extrinsic matrices and will take a point in 3D world coordinates and convert it to an $x,y$ coordinate system which is what the camera sees. Finally, we convert the $x,y$ coordinates to screen coordinates.  With the camera matrix calculation out of the way, let's dig into the implementation. I keep track of confetti using its center (in world coordinates), velocity, acceleration, and its two rotation parameters $\\theta$ and $\\phi$. I used a constant acceleration down at $-9.81$ (for obvious reasons). I initialize the position to be the center of the screen (the origin). I initialize the velocity randomly and uniformly from the top quadrant of a circle. I initialize the rotation parameters, and their deltas randomly.  The main approach is to keep a big array of confetti, and on each rendering step: - replace confetti that falls off-screen - update the world coordinates of each confetti (using acceleration, velocity, deltas for rotations, etc.) - extract the corners of each confetti given their orientation - use `world2image` to get the image coordinates of those corners - draw the quadrilaterals from those image coordinates.  Since we are calculating how each confetti would fall in real-time, large amounts of confetti (or badly optimized browsers), can really slow down a machine. Something to keep in mind if you use the website. Overall, I really enjoyed this project.  {{ addcomments }} "},
{title: "Why a Blog?", content: " # Why did I make a blog?  - I made it because it would be fun to have a blog - I think some of the things I've learned could be useful to other people - Trying to explain something clarifies it in a way that keeping it to yourself doesn't - Other cool people have blogs and I want to be just like them  # What can you find on this blog?  - Computer science, math, and whatever I'm currently interested in  {{ addcomments }} "},
{title: "Hilarious Random Number Generator", content: " I was searching for a chicken coop (as one does). I stumbled across a Facebook marketplace ad:  ![](/assets/1story.png)  The website it linked to had a live updating \"people viewing this item\" count:  ![](/assets/2story.png)  That seemed suspicious, so I looked into it.  ![](/assets/3story.png)  ![](/assets/4story.png)  They were just setting a random integer with jquery on a `setTimeout()`.   {{ addcomments }} "},
{title: "Bayes' Rule (in real life)", content: " # Motivating example  Let's say you're a doctor. A woman with no symptoms comes into your office after she's tested positive for breast cancer. Let's say the prevalence of breast cancer at her age is $1$ in $100$. Imagine we have a test that is $90\\%$ accurate when the person has cancer and $91\\%$ accurate when they don't have cancer.  We often refer to $90\\%$ as the \"sensitivity\" (since it's how *sensitive* the test is to the disease). We call the $91\\%$, \"specificity\", since it's how specific the test is for the disease.  The woman is stressed out that she tested positive. She asks you, \"How likely is it that I have breast cancer?\" **Is the answer 10% or 90%**? Many people make the mistake of saying $90\\%$. The actual probability is $10\\%$. This article will explain why, and how to avoid this mistake.  # A perspective on why this is wrong  My dad came up with a great way to think about it. Imagine a population of 1000 people and do the calculations on that. You know the prior is $1\\%$, so $10$ people have cancer, and $990$ people don't. Our test is $90\\%$ accurate when they have cancer; so, $9$ people who have cancer test positive, and $1$ person who has cancer tests negative. Of the $990$, our test is $91\\%$ accurate, so about $901$ people test negative, and about $89$ people test positive.  We know the woman tested positive, so she is either one of $9$ who has it, or $89$ who doesn't have it. $\\frac{9}{9+89}\\approx \\frac{1}{11}$ so she is about $10\\%$ likely to have cancer. That was a lot of calculation, and directly applying Bayes' rule isn't much simpler. We will create a framework for making these kinds of decisions that is mathematically sound, and easy to use in real life, even if you don't like [math](/404).  # An aside about odds  You may have heard your friends bet on something with $1:1$ odds (or even odds). This means the event has a $50\\%$ chance of happening. It is similar to the idea of \"parts\" in a cooking recipe, \"3 parts water\" and \"2 parts wine\" means the mixture will be $2:3=\\frac{2}{5}=40\\%$ wine. It's exactly the same happening here. $1:1$ is $50\\%$, $1:2$ is about $33.3\\%$, $1:3$ odds are $25\\%$. The idea is to go from the odds of: \"it happens $n$ times\": \"it happens $m$ times\", we go $$n:m = \\frac{\\text{times it happens}}{\\text{all the times}}=\\frac{n}{n+m}.$$ This is how you can convert odds to probability.  You can convert probability to odds using the following formula. Let's say the probability of an event $A$ happening is $P(A)$. The odds of it happening are $P(A):P(\\text{not } A).$  One nice thing about odds is you can cancel out common factors, so $2:4=1:2.$  # How do we fix our intuition?  You should think about the test---not as *determining* if she has breast cancer---but as *updating* your guess that she has breast cancer. Since the prevalence of breast cancer at her age (with no symptoms) is $1\\%,$ she has the odds of breast cancer of $1:99$.  Now, apply this formula (with $O$ representing odds): $$O_{new} = O_{old}O_{evidence}.$$ So, $$O_{new} = O_{old}O_{pos}= (1:99)(10:1) = 10:99 \\approx \\frac{1}{11}=0.09090909.$$ Thus, the chance that she has the disease is $10:99,$ about $\\textbf{9\\%}$. This is the key formula that you should use in your everyday life. It allows to you quickly incorporate more evidence into your calculation, or change your prior odds.  Where the hell does this come from? Don't worry, I will explain.  # You ask: Why is the formula you presented remotely true???  Intuitively, think about the [waterfall analogy](https://arbital.com/p/bayes_rule/?l=693) ![wide vs narrow waterfall](https://i.imgur.com/6FOndjc.png?0)  If the only thing we care about is the odds at the end (i.e. the ratio of red to blue at the bottom), then we only need to care about the odds that it goes in, $90:30$ or $45:15.$ Since they are the same odds, we end up with $3:4$ red to blue in both cases.  # The proof  We start with our prior odds, cancer:not cancer, which is written $O_{old}=P(C):P(\\lnot C).$   We want to know the probability of **cancer** *given* she **is positive**. In probability form, we write that $P(C\\mid +).$ This kind of conditional probability is really important to understand, and I can't explain it too thoroughly here, but the idea is when you say \"A given B\", you are restricting your universe of possible events to only ones where B is true, and you're asking, out of those times, how often is A true. That is, $P(A\\mid B) = \\frac{P(A\\cap B)}{P(B)}.$ We can rewrite this as $P(A\\mid B)P(B) = P(A\\cap B)$. This formula will be very important. You should also know that we can rename the A's to B's, so $P(B\\mid A)P(A) = P(B\\cap A)=P(A \\cap B)$. We will use this later.  The odds we want to know about can be written $O_{new} = P(C\\mid +):P(\\lnot C\\mid +)$. This will tell us our new estimate of the likelihood that the woman has cancer, given that she tested positive.  I claim that the question mark is true.   $$ \\begin{align*} &O_{old}O_{pos}\\\\&=(P(C):P(\\lnot C))\\cdot \\left(P(+\\mid C):P(+\\mid \\lnot C)\\right)\\\\ &\\stackrel{?}{=} P(C\\mid+):P(\\lnot C\\mid+)\\\\&=O_{new} \\end{align*} $$  Here is the proof: $$ \\begin{align*} (&P(C):P(\\lnot C))\\cdot \\left(P(+\\mid C):P(+\\mid \\lnot C)\\right)\\\\&=P(C)P(+\\mid C):P(\\lnot C)P(+\\mid \\lnot C)\\\\ &= P(+\\cap C):P(+\\cap \\lnot C) \\\\ &= P(+)P(C\\mid +):P(+)P(\\lnot C|+)\\\\ &= P(C\\mid +):P(\\lnot C|+)\\\\ \\end{align*} $$ ---  The last wrinkle to that calculation I showed earlier is how to calculate $O_{pos}=P(+\\mid C):P(+\\mid \\lnot C).$ The trick is that usually this is given to you or easy to calculate. $P(+\\mid \\lnot C)$ is the false positive rate, which if the test is $91\\%$ accurate when they don't have cancer is $9\\%$. And $P(+|C)$, which is the true positive rate, or sensitivity of the test, $90\\%$. Thus, the $O_{pos}=90:9=10:1.$  It should be clear now, that $$O_{new} = O_{old}O_{pos}= (1:99)(10:1) = 10:99 \\approx 9.2\\%.$$ This formula is amazing because it is very easy to add more evidence to update your understanding.  Let's say you reassure the woman. \"It was a routine checkup, you have no symptoms, we just need to run another test, it was probably a mistake.\" She does it again and comes back positive again. Now, she should start to get worried: $$O_{newer}=O_{new}O_{pos}=(10:99)(10:1)=(100:99)\\approx 50\\%.$$ Almost even odds. Okay, sure, but let's imagine that the second test came back negative. To understand the odds, we need to calculate the odds for a negative test. **Try this on your own and I'll see you in the next paragraph.**  Now, let's calculate this, $$O_{neg}=P(-\\mid C):P(-\\mid \\lnot C)=10:91.$$ This isn't as nice and round a  number, but it allows us to calculate: $$O = O_{old}O_{pos}O_{neg}=(1:99)(10:1)(10:91)=100:9009 \\approx 1\\%$$ Another great thing about this, is let's say we get more information that the prevalence in her age group is actually $1:10$. How do we incorporate that? Well, it replaces our prior estimate. So, $O_{old} = 1:10$ rather than $1:99$. Now, $$ \\begin{align*} O_{old}O_{pos} &=(1:10)(10:1)=10:10=50\\%\\\\ O_{old}O_{pos}O_{pos} &=(1:10)(10:1)(10:1)=100:1=99\\%\\\\ O_{old}O_{pos}O_{neg} &=(1:10)(10:1)(10:91)=100:910\\approx10\\% .\\end{align*} $$   # Unrelated: What does multiplying odds usually do?  The rule $(n:m) \\cdot (a:b) = an:mb,$ can be justified as follows:  $$ \\begin{align*} &(P(A):P(\\lnot A))(P(B):P(\\lnot B))\\\\ &= P(A)P(B):P(\\lnot A)P(\\lnot B)\\\\ &= P(A\\cap B):P(\\lnot A \\,\\cap \\,\\lnot B)\\\\ &= P(A\\cap B):P(\\lnot (A\\cup B)) \\end{align*} $$ This might be better understood by a very poorly drawn PowerPoint slide: ![](/assets/union-and-intersection.png)  {{ addcomments }} "},
{title: "Pick's Theorem", content: " # Theorem  The area of a closed polygon with integer vertices is determined by this formula $$\\frac{B}{2} + I - 1.$$ Where $B$ is the number of vertices on the boundary (blue in the figure) and $I$ is the number of vertices in the interior of the shape (red in the figure).  ![](/assets/picks_theorem1.jpeg)  # Proof  We will use induction on the area of the polygons.  ## Base Case  The base case is simply triangles that don't have any vertices on the interior.  It is easy to see that a isoceles right triangle with side length $1$, has area $\\frac{1}{2}$. This is clear from the formula for the area of the triangle ($\\frac{1}{2}bh$).  ![|300](/assets/picks_theorem2.jpeg)  A shear takes the form:   $$\\begin{bmatrix}1 & 0\\\\ a & 1\\end{bmatrix}.$$ $$\\begin{vmatrix}1 & 0\\\\ a & 1\\end{vmatrix} = 1$$  So, shears preserve area, and thus, when a triangle is scaled by a shear, it's the area remains the same, so all triangles that are just sheared versions of each other have area $\\frac{1}{2}$.   ## Inductive Step    {{ addcomments }} "},
{title: "Five Color Theorem", content: " # Theorem  For every planar graph, there exists a coloring of its vertices using at most 5 colors such that no two adjacent vertices have the same color.  ## Lemma: degree 5 vertex  ![](/assets/five-color-theorem1.svg)  To show that every planar graph has at least 1 vertex of degree $\\leq 5$, we assume euler's formula, that given $F$ faces, $V$ vertices, and $E$ edges of a planar graph, that $$F + V = E + 2.$$  We assume for contradiction, there exists a planar graph $G = (F, V, E)$ with all vertices of degree $\\geq 6$. Then let us consider the size of this set:  $$VE = \\{(v,e) : v \\in V, e \\in E, v \\text{ is adjacent to } e\\}$$  Every edge will be in there twice, so $$|VE| = 2|E|.$$ Also, we know that all vertices have at least 6 edges, so $$|VE| \\geq 6|V|.$$ Thus, $$2|E| \\geq 6|V| \\implies \\frac{1}{3}|E| \\geq |V|.$$  Next, consider the set:  $$FE = \\{(f,e) : e \\in E, f \\in F, f \\text{ is adjacent to } e\\}$$  Every edge can see 2 faces, so $$|FE| = 2|E|,$$ and every face has at least 3 edges, so $$|FE| \\geq 3|F|.$$ Putting this together, $$2|E| \\geq 3|F| \\implies \\frac{2}{3}|E| \\geq |F|.$$  Now, we apply Euler's formula to get:  $$2 = F + V - E$$ $$\\leq \\frac{2}{3}|E| + \\frac{1}{3}|E| - |E|$$ $$= 0.$$  Thus, $2 \\leq 0$, a contradiction. This concludes the proof.  ---  ## Proof  Now for the real proof. This proof is by induction on the number of vertices in a planar graph:  Base case: $|V|=1$, it is clear that this is 5-colorable with just 1 color.  ![](data:image/png;base64,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 )  Inductive step: We assume that all planar graphs with $|V|-1$ vertices are 5 colorable. We know from the lemma that there exists at least one vertex $w$ of degree 5 or less. We know that if it has less degree less than 5 that we instantly win because if we remove that vertex, it is 5 colorable (from our inductive hypothesis). And because $w$ has degree less than 5 it can be colored by a color that isn't in its neighbors. Thus, we can assume $w$ has 5 neighbors.  Now, because $w$ has 5 neighbors, if any two of them have the same color, then we can color $w$ the color that is missing, so we can assume that $w$ has degree at least 5.  To recap what we know so far: all planar graphs have at least one vertex with less than degree 5. The worst-case scenario for our proof is when it is exactly 5, and all of the neighbors have different colors. In all other cases, we win.  Now, we label the neighbors $v_1$ through $v_5$ based on their colors. We look at the largest subgraph that connects to vertex $1$ which only contains $1$ and $3$ colored vertices (it can have other colors hanging off of it). Now, if it doesn't contain $v_3$ then we can flip the color of each of the vertices of the subgraph (i.e. every $1$ colored vertex becomes a $3$ colored vertex). And then we can just color $w$ $1$ because it will have 2 vertices of color $3$ adjacent to it and no vertices of color $1$ now.  Thus, we can assume that there is an unbroken path from $v_1$ to $v_3$ which contains only $1$ and $3$ colored vertices. Now, we can apply the same exact logic to the colors $2$ and $4$. Thus, we only care about the case when there is an unbroken path from $v_2$ to $v_4$, as otherwise we can just flip the colors fo the subgraph coming from $v_2$ to recolor $w$ with color $2$. However, there can't be both an unbroken path from $v_1$ to $v_3$ using only $1$ and $3$ colored vertices, *and* an unbroken path from $v_2$ to $v_4$ using only $2$ and $4$ colored vertices. The paths have to cross because they are paths on a plane. This that case leads to a contradiction, so any planar graph must've fallen into one of the cases that was 5 colorable. Thus, every planar graph is 5 colorable. This concludes the proof.  ---  {{ addcomments }} "},
{title: "Linear Regression", content: " # Theory  We are trying to find the line of best fit given a collection of coordinates.  For example, $\\{(x_1, y_1), (x_2,y_2), (x_3, y_3), \\dots\\}$. We would like to find $m,b$ such that $y = mx + b$ minimizes the sum of the residuals squared. By that I mean we want to minimize a function $L(\\alpha) = \\sum_i (y_i - (mx_i + b))^2$, by finding the best $m$ and $b$.  We will use the notation from [here](/404). Here are some fun facts we'll need to know: 1. $\\sum_i x_i^2 =\\lVert x \\rVert^2$ 2. $\\lVert x \\rVert^2 = x^Tx$ 3.  $(A + B)^T = A^T + B^T$ and $(AB)=B^TA^T$. 4. $D ( u^Tx) = u^T$, $D (x^Tu) = u^T$, and $D(x^Tx) = D(\\bar{x}^Tx) + D(x^T\\bar{x})$.[^1]  We need to set up some definitions. Let $$y = \\begin{bmatrix}y_1\\\\ y_2\\\\ y_3\\\\ y_4\\\\ \\vdots\\end{bmatrix}, X = \\begin{bmatrix}x_1 & 1\\\\ x_2 & 1\\\\ x_3 & 1\\\\ x_4 & 1\\\\ \\vdots & \\vdots\\end{bmatrix}, \\alpha = \\begin{bmatrix}m\\\\b\\end{bmatrix}.$$  So our goal is:  $$\\underset{\\alpha}{\\text{argmin}}\\, L(\\alpha)$$ $$=\\underset{\\alpha}{\\text{argmin}}\\, \\sum ((y_i) - (m x_i + b))^2$$ Apply fun fact number #1: $$=\\underset{\\alpha}{\\text{argmin}}\\, \\left\\lVert \\begin{bmatrix}(y_1 - (m x_1 + b))\\\\ (y_2 - (m x_2 + b))\\\\ (y_3 - (m x_3 + b))\\\\ (y_4 - (m x_4 + b))\\\\ \\vdots\\end{bmatrix}\\right\\rVert^2$$ $$=\\underset{\\alpha}{\\text{argmin}}\\, \\lVert y - X\\alpha\\rVert^2$$ Apply fun fact #2: $$=\\underset{\\alpha}{\\text{argmin}}\\, (y-X\\alpha)^T(y - X\\alpha)$$ Apply fun fact #3: $$=\\underset{\\alpha}{\\text{argmin}}\\, (y^T - \\alpha^TX^T)(y - X\\alpha)$$ $$=\\underset{\\alpha}{\\text{argmin}}\\, y^Ty - \\alpha^TX^Ty - y^TX\\alpha + \\alpha^TX^TX\\alpha$$  To minimize this, we find the critical points of the function. We do this by finding where the derivative of $L$ with respect to $\\alpha$ is $0$.  $$ \\begin{align*} 0 &= L'(\\alpha)\\\\ &= D (y^Ty - \\alpha^TX^Ty - y^TX\\alpha + \\alpha^TX^TX\\alpha)\\\\ &=D (y^Ty) - D (\\alpha^TX^Ty) - D (y^TX\\alpha) + D (\\alpha^TX^TX\\alpha)\\\\ \\end{align*}$$ Apply fun fact #4: $$ \\begin{align*} &= 0 - (X^Ty)^T - y^TX + D (\\alpha^TX^TX\\bar{\\alpha}) + D (\\bar{\\alpha}^TX^TX\\alpha)\\\\ &= -y^TX - y^TX + (X^TX\\alpha)^T + \\alpha^TX^TX\\\\ &=-2y^TX + \\alpha^T(X^TX)^T + \\alpha^TX^TX\\\\ &=-2y^TX + \\alpha^TX^TX + \\alpha^TX^TX\\\\ &=-2y^TX + 2\\alpha^TX^TX\\\\ \\end{align*} $$  And now for the glorious part (who am I kidding, this whole thing has been glorious),  $$2y^TX=2\\alpha^TX^TX$$ $$X^Ty=(X^TX)\\alpha$$ $$(X^TX)^{-1}X^Ty = \\alpha = \\begin{bmatrix}m & b\\end{bmatrix}$$  # Examples  Say we are given this set of coordinates: $\\{(1.3, 0.8), (3.2, 3.5), (5.6, 6.4), (8.5, 7.7)\\}$. Then we can either do the arithmetic by hand (from the last equation) or open `julia` and give it the vectors (some output omitted): julia julia> y = [0.8; 3.5; 6.4; 7.7] julia> X = [1.3 1; 3.2 1; 5.6 1; 8.5 1] julia> inv(X' * X) * X' * y 2-element Vector{Float64}:  0.9628  0.1228   Which gives us our desired line of best fit: $y = 0.962823x + 0.122874$.    [^1]: The bar in $\\bar{\\alpha}$ or $\\bar{x}$ means treat it as a constant, in the same way, that you would if you were doing the product rule with single-valued functions: $D(f(x)g(x)) = D(f(x)\\bar{g}(x)) + D(\\bar{f}(x) g(x)) = (Df(x))g(x) + (Dg(x))f(x)$.    {{ addcomments }} "},
]
</script>
<input oninput="search(this.value, mystuff)"/>
<div id="results-div"></div>

<div class="page-foot">
    Â© Jason Eveleth 2023 Â· Powered by Franklin.jl Â· Last modified: August 05, 2023
</div>
</div><!-- CONTENT ENDS HERE -->
  </main> <!-- end of id=main -->

  <!-- if we're in an iframe -->
  <script>
    if (window.self != window.top) {
      console.log("we're in an iframe!!!");
      document.querySelectorAll(".blog-nav").forEach(i => i.style.display = "none");
    }
  </script>

  <!-- <script src="/blog/libs/vela/metisMenu.min.js"></script> -->
  <!-- <script src="/blog/libs/vela/slideout.min.js"></script> -->
  
  
  
    <script src="https://cdn.jsdelivr.net/npm/fuzzysort@2.0.4/fuzzysort.min.js"></script>
<script>
const $ = document.querySelector.bind(document)

function shorten(inputString) {
  // Split the input string into lines
  const lines = inputString.split(/\r?\n/);

  // Get the first line and the first 50 characters of the string
  const firstLine = lines[0];
  const first50Characters = inputString.substring(0, 200);

  // Compare the lengths of the first line and the first 50 characters
  if (firstLine.length < first50Characters.length) {
    return firstLine;
  } else {
    return first50Characters;
  }
}

function f(x) {
  const hl = fuzzysort.highlight
  const style = "style=\"font-size: 70%\""
  return `<div>${x[0]?hl(x[0]):x.obj.title}<p ${style}>${shorten(x[1]?hl(x[1]):x.obj.content)}</p></div><br/>`
}

function search(query, documents) {
  options = {
    keys:['title', 'content'],
    scoreFn: a => Math.max(a[0]?a[0].score:-Infinity, a[1]?a[1].score-100:-Infinity),
    all: true,
    threshold: -10000,
  }
  const results = fuzzysort.go(query, documents, options)
  $('#results-div').innerHTML = results.reduce((acc,x) => acc+f(x), "")
}
if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", search("", mystuff))
} else {
  search("", mystuff)
}

</script>

  
</body>
</html>
