<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Otter emoji icon!!! -->
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🦦</text></svg>">

  <!-- Open Graph https://ogp.me/ -->
  <meta property="og:title" content="Asymptotic Analysis of Dijkstras in Haskell" />
  <meta property="og:type" content="article" />
  <meta property="og:image" content="https://www.jasoneveleth.com/blog/assets/otter.png" />
  <meta property="og:image:width" content="160" />
  <meta property="og:image:height" content="160" />
  <meta property="og:article:author" content="Jason Eveleth">
  <meta property="og:article:published_time" content="2023-11-05">

   <link rel="stylesheet" href="/blog/libs/katex/katex.min.css">
   
   <link rel="stylesheet" href="/blog/libs/highlight/styles/github.min.css">
   

  <!-- not used -->
  

  <link href="/blog/css/franklin.css" rel="stylesheet">
  <link href="/blog/css/global.css" rel="stylesheet">

  <title>Asymptotic Analysis of Dijkstras in Haskell</title>
</head>
<body>
<nav class="flex-container blog-nav">
  <!-- type-a have a fixed width which never changes -->
  <!-- type-b will grow up to a point -->
  <!-- type-c start at 0 and absorb remaining space-->
  <!-- https://jsfiddle.net/dehsq3jb/ -->
  <div class="type-c"></div>
  <div class="type-b link-spacer"></div>
  <div class="type-a logo"><a href="https://www.jasoneveleth.com">Jason's</a> <a href="https://www.jasoneveleth.com/blog">Blog</a></div>

  <div class="type-b content-spacer"></div>

  <div class="type-a nav-link"><a href="/blog/search">Search</a></div>
  <div class="type-b link-spacer"></div>
  <div class="type-c"></div>
</nav>

<main id="panel">

<h1 class="post-title">Asymptotic Analysis of Dijkstras in Haskell</h1>
<!-- <hr> -->
<!-- Content appended here -->
<div class="franklin-content"><p> 
<details class="toc">
<summary>Table of Contents</summary>
  
</details>
</p>
<p>Imagine you have a map of the US. You want to know the distances from Providence to all the other cities. We can turn that map into a network of cities and distances between them. In math and computer science, we call this a graph &#40;and we refer to the cities as vertices or nodes&#41;. Our goal in this post is to using functional programming to find the shortest distances from Providence using Dijkstra&#39;s algorithm. It&#39;s going to get CS-heavy in the rest of the post so buckle up.</p>
<div class="im-quarter"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALEAAAE1CAIAAAAnHZboAAAABmJLR0QA/wD/AP&#43;gvaeTAAAgAElEQVR4nO2deUDM2///z3v2pppq2vfSqgUVKiEpVFxLdEuUbLnWEML1kfuTK1xXlksh2UKWsi8VIVGWsrZNpJUm2pdpamZ&#43;f7y/n/nMrWmafYbej7/MeZ8556WenXPe57zO6wWxWCyAgMABStYGIMgdiCYQeoJoAqEnGOl0Q6VSP3361Nra2tTUhMViiUSilpaWmZmZoqKidAxA4B9JaYLFYuXm5qanp2dmZr5&#43;/bqhoYFrNSMjIxcXFw8PDx8fH2NjYwkZgyAQkNjfO&#43;rq6uLi4k6fPl1aWmpoaOjh4eHq6mppaWlmZkYikVRUVOh0ent7e21tbUlJSWFhYVZW1uPHj9vb28eOHbtw4cKAgAAsFitekxAEgyU&#43;qFRqeHg4kUjU1NRcs2ZNfn4&#43;n1&#43;k0&#43;nXr1&#43;fNWsWFos1MTGJi4vr7u4Wo2EIAiEeTTCZzPj4eDKZrK&#43;vv3///ra2NuHa&#43;fz587Jly3A4nKOjY25urlhsQxAUMWiirq5u8uTJGAxm1apVzc3NojdYUlIyadIkNBodFRXFYDBEbxBBIETVxJs3bwwMDIyNjZ89eyYWg2CYTOb&#43;/ftxOJyvr29ra6sYW0boF5E0kZWVpaqq6uHhUV9fLy6DOMnNzdXS0nJ2dv727Zsk2kfgivCaeP78uZKS0owZM2g0mhgN6kFJSYmJicnw4cPFMish8IOQmqBQKJqamj4&#43;PnQ6XbwG9aa0tFRbW3vChAldXV2S7guBJZwmOjo6HBwcnJychH6/EJS8vDwFBYXNmzdLp7sBjjCaWLVqlYqKSmlpqdit4cHx48dRKNT9&#43;/el2enARGBNPH/&#43;HIVCnTp1ShLW8MbPz8/CwkKiyxcEFosl2N42i8UaOXKkkpLSgwcPIAiS3O4qVyorK21sbDZt2rR582Ypdz2wEEhBN27cgCCI/01rsRMVFUUmk5F3EIki2DgxevRoNTW1GzduSE6jvGloaDAxMdmyZcv69etlZcPPD//yef/&#43;PQDgwYMHEhMoX4SHh1tYWDCZTNma8RMjgJ/VqVOnjI2N3d3dJaZPvggJCaFQKDk5ObI14ydGAE1cu3YtMDAQhZKxu56jo6OlpeW1a9dka8ZPDL9&#43;VjU1NSUlJV5eXv3WrK6uvnTpEoVCUVdXHzdunKura0VFBYPBsLGxEc3U/&#43;Hl5ZWZmSmu1hB6wO8ffVZWFhaLHTVqFO9qO3fudHFx6ezsDAsLCw8P7&#43;rq8vHxGTNmTElJicim/o9x48a9evWqvb1djG0i/A8&#43;1x1RUVFWVla86&#43;zbtw&#43;LxT558oSzsKOjw9nZ&#43;cSJE0IueLhRUFAAAHj9&#43;rUY20Rgw&#43;84UVJSYmVlxaPC&#43;fPn16xZs337djc3N85yAoFw8ODB&#43;vp6oVXbGzMzMwwGU1xcLMY2Edjwu56oq6sbNGgQjwrR0dEAAF9f396PRowYwfrvLgiFQrl9&#43;3ZjY&#43;PIkSN9fHwAALdu3WpubgYAQBA0Y8YMPB6fl5cH/74nT55MIpF6N4jD4dTU1Orq6vg0HkEw&#43;BxPXFxc1q5d29dTCoUCAMBgMJ2dnTwaWbly5ZgxY759&#43;5aWlgZBUExMDIvF&#43;vLli5OTEwCAPekwmUxfX9/z58/zaGrQoEE7d&#43;7k03gEgeB37ujs7MThcH09/fz5MwDA3NycRx0AwOnTpydNmqSurj5hwoTBgwdfvXoVAKCjoxMTEwMAKC8vh6t1dXURCITAwEAeTREIBBqNxqfxCALBryYUFRV5rPMxGL7moFu3bi1duhQA8Pz5cxaL1dHRAZd7eXkNHjw4Li4O/piSkuLv78&#43;7qdbWViUlJb5MRxAQfjWhrKwMz/pcsbCwAABQKBT2r5krbm5ujx49Cg4Ohj3qWBxHLStWrMjKynr79i0AIDU11c/Pj7c9LS0tysrKfBqPIBD8asLQ0JA9tvdGX1/f1taWwWDAZyK9gX/9GzZsOHHixLFjx&#43;bOnYvH4zkrhISEkEikQ4cOFRYWWlhY8J6DmpqaGhoajIyM&#43;DQeQTD4XHfs3btXT0&#43;PR4XLly8DAMaNG9d7mUmlUhMSEl6&#43;fAkAuHPnDlw4ffp0e3t7zmorV64kEonz588vLy/nbUxubi4A4NOnT3wajyAQ/GoiPT0dAFBdXc2jTnR0NARBISEhnDcyysvL165dS6fT4Y2mJUuWdHV1paenm5qaGhgYlJSUsH&#43;1RUVFEARNnTq1X2P&#43;&#43;ecfEomE3B&#43;UEPxqoq2tDY/Hnz17lne1y5cv29nZKSgouLu7L1&#43;&#43;fPHixdu2bWOPHMHBwSgUSltbOy4uLjo6GoVCrVu3jvPrEydOvHv3br/GzJw585dffuHTcgRBEcB/wt3dPSgoiJ&#43;ara2tz549q6ur6/2ISqWy3f973xSqqKjo1zGCRqOpqant27ePH0sQhEAATRw&#43;fJhIJMrc7&#43;3KlSsoFKqyslK2ZvzECOAMERAQwGAwLly4IJG1Lt&#43;cOHFi/PjxBgYGsjXjZ0YgBS1cuNDMzEyGi7vXr19DEHTjxg1ZGTAQEMxHl0KhDB48ODExMTg4WHIy5YGfn19ZWVleXp70bxIMIAQV0ZIlS3R1dRsbGyUg0H64e/cuAICfFxMEURA4nlV9fb21tbWfnx/7eEI6tLS0ODo6Dh06FN4cQ5AgQujo8uXLEAQlJyeLW6C8mD17tpaWVk1NjTQ7HZgIGWtg&#43;fLlJBIpLy9PvNb0xV9//QVB0MyZM5FwA1JASE10dnZOmDBBW1ubQqGI16DenD59GoKgefPmKSgoTJgw4fv375LucYAjfJya5ubmESNG6OrqvnnzRowG9eDIkSNoNHrjxo0sFis/P9/ExMTMzOzdu3eS6xFBpHhWTU1N48ePV1VVvXnzprgMYtPV1bVhwwYIgrZv384urKur8/DwUFJSunLlith7RIARNe4djUabP38&#43;BEEREREdHR1isYnFYpWVlY0ePZpIJJ48ebLHo66urlWrVkEQFBkZiURKlATiiZl66tQpZWVlMzMz0QeMjo6O6OhoIpFoa2vLY46Ij4/H4XBTpkxpamoSsUeEHogttnJVVVVAQAAAwMXF5caNG0L8BTc3N//999&#43;6urqKioo7d&#43;7k7QLOYrGePHmira1tb2//8eNHYa1G4II4422zWKycnJxffvkFgiADA4MNGzY8efKk38B49fX1KSkpQUFBRCJRSUkpIiKC/02IysrK4cOHk8nk9PR0kW1H&#43;D/EH5cfAFBcXHzmzJmkpKTPnz8rKSk5OTlZWVmZmJioq6srKyt3dXW1trZSqVQ4Lj88Qbi6ugYHB//6669qamoC9UWj0ZYsWZKUlLRjx47IyEix/18GIBLRBBsKhZKZmZmfn19cXEyhUFpbW1taWrBYrJKSkqamprm5ubW1taurq7u7O5lMFqWj/fv3R0REBAYGHjt2TEFBQVz2D1CkMxwxmUwMBnPu3DnJdXHnzh1VVVVHR8eKigrJ9TIQkFKAke/fv3d3d2tpaUmuC29v7&#43;fPn3d0dLi4uMCO3QjCISVNUKlUAIBENQEAsLCwyM3NHTFihLu7e2JiokT7&#43;on5qTQBAFBWVk5NTd24cePChQvhewOS7vHnQ3qaQKFQ6urqUugLgqBt27adP3/&#43;7NmzXl5eSEgCQZGeJtTV1fm8aiwWAgICsrOzKyoqXF1d&#43;7qxiMAVKWmirq5OChNHD4YNG/bixQsjIyNXV9eUlBQp9/7jwpcm2traLly4EBERAccJ4V05Pz9/y5YtR48ebW1tZRdSqVTpawIAoKGhkZaWtmDBglmzZm3cuJHJZErfhh&#43;Pft9Wv3z5Ymlp6evrq6KiAgBYuXIlj8onTpzw8fH5/PnzqVOnnJyc2FfB/Pz8AgICxPL2LBzImRn/9K&#43;JqKgo&#43;O5Xe3v7kCFDiERiXz/WDx8&#43;KCsrs08rJk6cuHTpUvjfo0eP5i0mKYCcmfFJ/3PHpk2b4OgfCgoKISEhEAT1FRxi3bp1FhYWurq68Mfx48cnJCRUVlYCAKhUqqamptgGN6Fwc3N7&#43;fIlHo8fMWJERkaGbI2RZ/p/EeAMHlJXV7d69WoCgcC1Zl5enoeHB/ujiYkJnU5PT09fsGCBiOuJ8vLypKQkKpU6bNiwOXPm8E5eXVJS8vz5c/jfKBQqICAAjUbDHw0MDLKyssLCwry9vZEzsz7hf0h58eLFjBkz&#43;rr3DW8DLF&#43;&#43;nF0Ch0nfsmVLZ2cnBEEpKSnCDWUfPnxQVFQ0MDCApeDo6NjS0sKjPmeUeF9f394VmExmTEwMCoWaM2dOe3u7cFb9xPC1YdDa2rphw4aTJ092dHSsXbt2165dvaePd&#43;/eAQA4d6XgyaKyspJKpbJYLKHHiYSEhIyMDBcXl&#43;rq6oiIiOTk5B07duzcuZNr5cePH9vb28fGxsIf9fX1e9eB/faGDBkSFBTk6el55coV9nwnHEwm882bN3l5eSUlJeXl5Q0NDe3t7TgcjkgkkslkS0tLKyurUaNG6enpidKL9OBTO0wm88WLF66urgCAM2fO9K5w//59AACnPy28UxQZGfnq1SsAgHBe/w0NDZwDzOfPnyEI8vDw6Ku&#43;t7c3/y45JSUlgwcP1tPTy8nJEcK2zs7OlJSUmTNnwgf9ioqKDg4OM2bMWLhw4cqVK5csWRIcHOzj42NmZgZPXlZWVmvXrpWom7tYEOysvLGxUV1dnetbJRz5ljOuKnw4eebMmTt37gAAxPUSaGdnFxYWxvXRkydPAAAkEsnPzw8Ot9gvzc3NU6dOxePxAkUE//79e1RUlIaGBgqF8vT0jI2Nffv2LY9oKm1tbWlpaRs3bjQzMwMAODk5Xb58WW4djAX2n/Dz85sxY0bv8s7OTjKZPHv2bHbJxYsXAQB5eXmnTp0iEAgimflfGAyGoqJiX478169fDwwMtLW1hSAIg8Hs2bOHnzaZTGZUVBQEQWFhYf16CtLp9J07dyorK6urq0dFRQkaGoXJZGZlZc2aNQuFQtna2mZmZgr0dekgsCbc3NxiY2O5PlqxYoWBgQH745YtWzQ1NWk02p49e4yMjIS3kYPU1FRnZ&#43;d&#43;4xvdunULXtmkpaXx2fKFCxeIRKK7uzu8&#43;uHKixcvBg8eTCQSt2/fznud2y&#43;FhYVTpkyB77fJPPRPD/rRRFdXV1JSEvuvITMz08HBge1Rff/&#43;/cDAQPZlvcrKSh0dncePH7NYrJaWFi0trfj4eBaLtWHDhuHDh4tuK51OHzlyZFFRET&#43;VKyoqSCSSQKHQ8vPzjY2N&#43;7pntn//fjwe7&#43;XlJcYYjFevXtXW1rawsJBhKsbe9KOJ2tpaMpmMxWKnTZs2ffr0lStXcr68rVu3DgCQm5vLLsnNzfX09Ny9e3dQUBB7OAkNDeX6Tigoy5Ytu3XrFv/1Q0JCLC0tBeqCfc&#43;Mc2HLYDCWL1&#43;ORqOjo6PFvgj48uUL3OO9e/fE27LQ9D93MJlMCoXC1cmxq6uLa4bqT58&#43;cf7sfH19Q0NDRbGSxWLFxsYmJiYK9JVz584JETKxxz0zBoMRFBSEx&#43;MldxuRTqeHhITgcDg5ufAoDR/d4cOHb9iwQZQWEhIS9u/fz/7IZDILCwv7/daWLVsElRGbf/75B4vFzpw5c/HixQQCISMjQ7h2&#43;ITJZC5btgyPx8s8VSdLOpowMjLi8xWAK0eOHHF1dU1MTExMTDxx4sSBAwd8fX3hVQvngobBYKxbt&#43;769evwEJWZmclnNM&#43;&#43;ePjwoZOTExqNFnoHViAYDEZgYKCKiooUwjfwRhqaUFBQEDrnPVdXW1NTU/jVg3NBw2Aw4F1tPT296dOn79y5U8T4fDk5OVgsFk48Ix1oNJqTk5OjoyONRpNap72RuCaampoAR&#43;h18dJ7QVNTU1NVVSV6yx0dHRYWFt7e3lLeWSotLSWRSJs3b5Zmpz2QuCbgtFCvXr2SdEfiZdu2bUQisaysTPpdHzhwAIfDFRQUSL9rGIlrIjs7GwDwY4VC/vr1q4KCwu7du2XSe3d397Bhw6ZNmyaT3llSuAdWW1sL/ntG&#43;qOwb98&#43;Eom0YsUKmfSORqO3bdt2/fp1&#43;KhZ&#43;khcE1QqVVVVtUdWH3mmvb09Li5uzZo1MryLPHXqVHt7&#43;7///lsmvUtDEzLx2Baa1NTUtra20NBQGdoAQdDixYsvXbrE6fsuNSSuCZnc7BCFpKQkX19fbW1t2ZoRGBjY1dV1/fp16Xct8YtZP9Y4QafTHz9&#43;vH//fq5Pnzx5AmdShUGhUGQyWUdHx8bGhndSOyHQ0NBwdXVNT08PCgoSb8v9gswd/yInJ6etrY3T05gTNzc3DQ2NkJCQtWvXMhgMMpn85cuXTZs2DR48&#43;NKlS2I3xtPT88GDB2Jvtn8k/WJja2u7detWSfciLvbt26etrc27DplMtrKy4ixZvXo1ACA1NVW8xqSlpQEAuKbQkijSGCd&#43;oBfR4uJiKysr3nV6TxMrV64EAJw8eVK8xsCWlJSUiLfZfpHseoLBYNTX1/9Ac0dZWZm5ubmg34L3YDi10tnZ&#43;ejRo0ePHunp6Xl7e8NumDBPnjy5c&#43;eOoaEhCoUKCwvj0ayhoSEej//48eOoUaMENUkUJDtOfPv2jcFg/ECaaGpqUlVVFegrjY2NmzdvJhAIS5YsgUtoNJq3t3dDQ8P69etZLJaDgwP7VntkZGRFRcXvv/&#43;uqqoaERHBu2UIgkgkEo&#43;U4BJCsuOE1MLTiIu2tjZFRcV&#43;q5WXl0&#43;ZMoVIJJaWllIoFAKB8OLFCzs7O/jpwoULTU1N4QiyK1asePTo0dy5c0tKSrS1tRMSEp4&#43;fUokEgMDA&#43;E7UbwhkUgtLS0i/qcERbLjxA&#43;nCRQKxU88AiMjo5s3byYnJ1&#43;6dCk&#43;Ph6CIB8fn9OnTwMA2tvbL1265ODgwK68dOnSjo6OxMRELBarrKzs5eUFX274/fff&#43;&#43;2ou7ubfbFRakhcE2g0WsTYl9JESUmJn61DOEMdBEFmZmZBQUG5ublfv35dsGBBUVHR06dPu7q6OCPyWFhYgP8uFQ8dOtTa2urr6ztq1KiGhoZ&#43;O2ppaYEvcEsTiWtCU1MThZJSNBzRIZPJ3759E/RbpqamI0aMYDAYz58/ZzAYAICnT5&#43;yn2poaAAALC0tAQCTJ08uLS1dvXr1q1evhg8fXlhYyKPZrq6u5uZmQQMLi45kf1s/3Ma2ubm5cO9&#43;379/BwC4ubk5ODjg8XjYQwAGvl09ZsyYtra2Y8eOkcnkffv2PXz4sLW19fz58zza/PTpU3d3NywmaSLxceLH0oS1tXVxcTGPJQWdTu8RSK&#43;qqmrdunUlJSWhoaFmZmZaWlorV64sKyvLzMyEK1y9etXf39/d3R2&#43;cEaj0QAArq6uFhYWvHduCgsLIQiCpx5pIvH3DpkfJgmEs7Nzc3PzmzdvOBeJbB4/fnzgwAEGg/Hx48ehQ4caGRl9/foV3tKIj49nbzbs2rWLyWQGBAQsWLDg69evHR0dcEozAEBjY&#43;PIkSMXL15cX1/v5ub222&#43;/8TAmKyvL3t5eSUlJEv9TXkh0l9TV1XXNmjUS7UK8MJlMDQ2Nv/76S/Sm2tvb8/LyOHMfMZnMtra25ubmV69e8XO1cOjQoeHh4aJbIijSWGNKtAvxAr9ViiWtrYKCgoODA2dMHwiCiESisrKyo6Njv3/9FArl7du3vr6&#43;olsiKMh6oidBQUE5OTlw6AQZcvbsWV1dXU9PT&#43;l3LUFNdHR0wDeJJdeFeKFSqbt27VqyZImOjs6hQ4dkaAmNRjt27FhISIj0N6wAkOR6AnY/ES4EjJR5/vx5cHAwHo9XV1ffsGFDdHQ0gUCQYR7sgwcPEgiE6upqmfQuzveO&#43;vr64uJiKpXa3t7e1tbW3t5uYmLS2NjY2dkpnz66dDr92rVrR48ezcjIsLa23rVr1&#43;LFi4lEYkdHx&#43;HDh7dt2xYfHy99q5qamnbs2LFkyRKZxb8SUVPl5eUHDx708/PjnCPQaDQcdJf90draeunSpZcuXZKTOHNfvnyJiYkxMDBAoVBTpkxJT0/vEefk3LlzKBRKJoPcypUrNTU1ZZiCW0hNdHd3nz9/3sPDA4VCqaioTJ069e&#43;//05LS/v8&#43;TPnXceWlpa3b99evnx506ZNzs7OGAyGRCItWLBAhiE4Xr58GRwcjMVitbS0IiMjy8vL&#43;6o5YcIEKysrEePRCEp6ejoKheqdaVeaCKwJJpN56tQpc3NzNBo9Y8aMa9eu9RsDik1tbW1sbOyQIUMgCJo8ebI0lUGj0S5evAjH7XN0dIyPj&#43;93xKqurtbS0goKCuo3VJK4qK6u1tbWDgwMlE53fSGYJt69e&#43;fm5oZGoxctWsQ1Ggk/MJnMmzdvwsPG6tWrJf2HWFNTExUVpampicPh/P39BcpEmpaWhsFgfv/9d8mZx6axsXHIkCGDBw&#43;WeZR4ATRx&#43;PBhAoHg4uIilr9vJpN5/PhxDQ0NKyur169fi95gb&#43;BpAoPBaGtrR0ZGCndnNTExEYIgSUccaGxsHD16tL6&#43;/ufPnyXaET/wpQk4uA4ajY6KihIxqEMPampqxo0bRyAQkpOTxdUmjUY7derUkCFDAABOTk7x8fGcG8xCcODAARQKtW7dOglNIjU1NUOHDtXT03v//r0k2heU/jXR1tbm4&#43;OjpKR09&#43;5dSVjQ3d0dHh6OQqEOHTokYlMfP36MjIxUV1fH4/H&#43;/v5Pnz4Vi4UsFispKQmHw/n4&#43;Ijds/7Bgwe6urpWVlYyiWvAlX40QafTfX191dXV&#43;QxLKzR//vknBEHHjx8X7utZWVn&#43;/v4YDEZXVzcqKopHjEuhycnJMTEx0dPTu3z5slgabGlpiYiIQKPRs2bNamxsFEubYqEfTYSGhiopKXFGO5Qc//nPfzAYjEDRDltaWuLj42HnWCcnp1OnTvH/EiQE9fX1oaGhEARNnDhRlK2Lzs7O48eP6&#43;vrk8nko0ePitFCscBLE0ePHkWhULdv35aaNaGhoWQymZ91FoVCiYyMVFNTw&#43;PxwcHBElqlciUrK8vFxQUA4OXllZycLNBipbKyMiYmxtjYGIfDLVmyRBLjmej0qYmCggIFBQXpvIaxaW9vt7e3d3Nz6yuKFIPBSE9P9/f3R6PR&#43;vr6UVFR375961Hn3r17N2/e7LevvLy833//PT4&#43;XriX4fT0dB8fHzQaraqqOmvWrMOHD/flFVFTU5ORkbF161Y3Nzc4yWp4eLg8J1Xnrgkmkzlu3DgnJ6euri4pG/Tu3TssFhsXF9ejvKmpKT4&#43;3sbGBgDg5uZ28eLF3ralp6dPnDgRALBt2zbevfSVy05Qampq9u/fP2XKFLZ3tZ6enqWlpZOT07BhwwYNGsQuHzRo0MKFC1NTU9mRqeUW7po4f/48CoWS9LqyLyIiIshkcn19PfyxuLh41apVSkpKSkpKYWFhXINhw3R0dJSVlfWrCR657ISmq6uruLj42rVr48aNW758eWRk5KZNm2JiYo4ePZqZmfn161cR25cmXDTBYDBsbGzmzp0rfWtgmpqa1NTUtm3blp6eDgevNzMzi4mJ4edYiE6n96sJHx8fR0dH9seYmBgcDieWwbytrQ0AwM/MJc9w8am5ceNGUVHRpk2bJHAKyxckEmnVqlV///33pEmTGAzGrVu3SkpKIiMj&#43;bk7xI8TSl5eHqeDPDuXnUhGAwD&#43;e5n4B3Ij4goXTRw7dmzSpEnwzC0rVqxYQaPRdu/effv2bR8fH/5vDbFvaPVV4du3b7W1tZx5y0xMTAAA8KQjIj/cXUiu9PxZ19bW3rt3LyQkRCbWsNHQ0PDx8bl3757YW&#43;aRy070xmFN/Fhuyb3pqYnbt2/D2TpkYg0nAQEBmZmZYr9VzWKxAACcGUo7OjoAADo6OqI3TqVSlZWViUSi6E3JkJ6&#43;d5mZmaNGjeIMDckZ2AuCIC0tLVNTU2NjY/jHevPmzcbGRnZlHx8f9p9gXl5eQUEB/G8VFRU48Pb/9YrBqKiokMlke3v7vn6Cnp6eDAYjKytLvP7sBgYGAADO&#43;7vwwpAdKUAUfkQ/9d70HCeys7M5c7YCANzc3NTV1YODg9esWfPly5enT59OnTrVyMgIjrY0ZsyYnJyc4ODgpUuXDhs2jHNMtrGx&#43;fDhw7x58/B4vK&#43;vr6amZkhIyMqVKykUCo1Gy8/Pj4mJUVdX9/X1LSoq6m2ZlpbW4MGDOS9eigUTExM4Nhm7pLy8HABga2sreuN1dXU/&#43;sQBwL/9MTs6OtBoNNdsMyQSydbWFv739&#43;/fzc3NIQiCHSna29u1tbUxGAx7R4FNbGwsZ&#43;r63tHBMjIydHR0CAQC1&#43;ODWbNm&#43;fn5CfQeBV/r5v0u2lcuO4E64sqcOXOmTp0qejuy5V/jRGlpKYPB4HqRGYfDsRfzZDIZTjF64cIFAICCgsLSpUu7u7vZEXrYXL9&#43;ff369ZyN9Kjg6emZkJBAo9FmzpzZ2dnZ4yl8o1cgicP7E/B0wObBgwezZ8&#43;ur6&#43;HP0ZGRnZ3d2dlZQEAWltbjx49Gh0dLRbP8p9w7oBvTPNz65dEIgEAqqqq4I&#43;//fYbHo8/ePAgZ52ioiISiWRoaMi7KV9fX09Pz&#43;rq6t4hJrW0tASKBvHs2TM4SFRqaurhw4e7u7vh8jt37ly4cKG0tBT&#43;aGBgcO3atT/&#43;&#43;GPPnj1LlizZvHkz71hj/PNzaOJfcwccyZer86qGhoadnR3747BhwwAAnLl7582bBwDgTKK6evXqHm44Ojo6PeYOmC1btgAAFixY0KM8MTGRSCTyP&#43;j1BZ&#43;57ERHV1d33759YmxQJvxrnOjq6gL/fk/jpKWl5eXLl9nZ2bNnz379&#43;nVoaChnoPLw8HAAADsqcUdHx5MnT&#43;ATqX6BZ6veOwQ4HA6eC0QEg8FwRiNkY2pqKsYYOiwW69u3bz/BOPGvnwgc8q29vZ1rVTQaXV5e/uLFi4kTJ75&#43;/Rp2XmU/dXBwGDNmzPXr1&#43;ENweTkZH9/fx77iZzA03/vFXtra6sMoi8IS319fVdX10&#43;giX/tT6&#43;/OXUAAB1CSURBVMAHu83NzfByoQdEInHmzJk82goPD8/Kyjp06NDevXsTExOvXLnCpxHwQrL3bnpflsgnP8fGNugxThgbGwMRdv6nT59ubGyckJCQlZVlaGgIx/bqFzqdfvPmTQwGM2PGjB6PPn36BJv0Q/BzakJPT09ZWZnr6x&#43;8&#43;uDdFhqNXrFiRVNT06&#43;//rp06VI&#43;LdizZw8cCq73OMFP9Gv5oa6uDoIgPv8S5Joea043N7ewsLAehZ2dnSgUytDQsN8la0NDg6Kior29fe9HdDodjUZzvnfQaLTVq1djsdhNmzb13jLq7u5WU1M7cOBAv53KCf/884&#43;GhoasrRADPc87xo0bd/HiRc4SOMcJk8msrKxctmzZ/PnzR4wY0ZfCVFVVQ0JC7O3te5RnZWXt378fjg7m6OhoYmKCQqE6OzsNDAxycnIcHR17N5WXl9fQ0DB&#43;/Hhh1S5tfpLNCdBrnIAj&#43;BUXFwutstra2ra2NtGUymKxWNu2bdPV1ZXa/V3RWbZs2bhx42RthRjo&#43;XY&#43;duxYAwODs2fPCi0yLS0tsRwWnzt3LjAwkM&#43;3WXngpxknemoChUIFBQWdPHkS3r&#43;SFY8ePSopKZk7d64MbRCUn1YTAIAVK1bU1tYmJSVJ3xo2f/75p7u7O9d1htzywwV&#43;7AsumjA0NJwzZ86ff/7Z&#43;6BSOmRnZ6elpfGTykCu&#43;GnGCe73OyoqKpSUlKKjo6W8umH9N1v3hAkTpN&#43;1KHR1dUEQJK7rxbKlz7uBMTExRCKxoKBAmtbA/eLxeFFefGRCdXU1AODx48eyNkQM9KkJOp3u4uJiZ2cnzUh12dnZWCx2z549UutRXOTn5wMAioqKZG2IGOjzpBiLxV64cKGmpmbevHn8pEMSnfLycn9/fzs7u75SvsozP81hB&#43;AdW9nY2DglJeXGjRsrVqxg9XfYISJUKnXSpEmampqamppjx46Fvfp&#43;IKhUKhaLFTTnoJzS70iSkpKCxWLnz58vuTvmZWVllpaWZmZmNTU13d3dkZGRAIBVq1aJN3aWRNm7d6&#43;&#43;vr6srRAPEIuPAeD27dv&#43;/v5jx449c&#43;aM2M/9srKyAgICtLW179y5w754c&#43;7cuUWLFrm7u58/f15qf3zl5eVJSUlUKnXYsGFz5szpy9&#43;soaHh1q1bPQozMzPz8/Pz8vIkb6bk4VM7ubm5xsbGBgYGDx48EJce6XT69u3bMRjMtGnTegeFfPXqlaGhoYWFhXTefT58&#43;KCoqGhgYABLwdHRsa9YJTt37uz9Yxw/fvykSZOkYKcUECA&#43;5vfv32fMmAFB0Jw5c0QPGX///n0bGxsFBYV9&#43;/b1ddBVXV3t7OysrKx87do1Ebvrl7Vr1z579ozFYlVVVcHpYjdu3Ni7GpPJdHFxuXjxYkFBQVlZWVlZ2fPnz5WUlHx8fIKDgyVtpHQQOLbytWvXTExM8Hj80qVLKRSKoF9nMBh3794dO3YsAGDy5MkfP37kXZ9Go82fPx&#43;NRks0amlDQ0NKSgr74&#43;fPnyEI8vDw6F2zrKysR&#43;ys&#43;Pj4gIAAZ2fniIgIyVkoTYSJwU6j0Y4cOWJiYgJBkJub28GDBwsLC/v9ysOHDyMjI&#43;HrHpMmTRJoeyc&#43;Ph6DwQQGBorlFJ4f7OzsevsWccXLy&#43;vKlSumpqaSjrUrNfhaY3KFwWCkpaWdPXv25s2bzc3NOjo6dnZ2lpaWenp6ioqKRCKxqamptbW1rKysuLj4/fv37e3tgwYNCgwMDA4Otra2FrS7tLS0wMBAExOT1NRUSTtpMplMEol0&#43;vRpPz8/3jW/fftmYWFRU1Ojqal58ODB&#43;fPnS9Qw6SC8Jth0d3e/evUqKyurqKiopKSktra2tbW1o6NDRUVFUVHRyMjI2tra3t7ew8MDjv4hNB8/fpw2bRqVSr106VKPi87i5erVqzExMc&#43;ePevXe&#43;PYsWMPHjxISEhQVFS8efPm5MmTJWeV9JD1QCUYLS0t06dPx&#43;PxQkfc7Rc6nT5y5Eg&#43;d6knTJiQkpLy6dMnAICsQsKJnR9MEywWi8lkxsTEQBAUFhYmiai5y5Yt4zOW77dv39TU1Do6OnJycgAA8hBSXyz8MNnl2UAQFBkZmZycnJSU5OXlBR80iIv9&#43;/ePGDGCzygoqampPj4&#43;BALh5whZxObH0wQMHHa/oqLC1dX1/fv3YmnzxIkTEASxL8GyWCyuwVLYXL58&#43;ddffwUAUKlUJSWlHz1kEZsfVRMAgCFDhrx8&#43;dLY2NjV1bV36AtBiYuLO378OIlEOnnyZGJi4sGDB6dMmQIHX&#43;gRvgKmvr7&#43;5cuX3t7e4GfysIKR9eQlKl1dXatWrYInFKEDByQmJvb&#43;yZiamsIbrOvWrQMA9EhOkJCQwA4ru2bNGhcXFxH/I/LDD68JmPj4eBwON2XKFEkk0&#43;IavqK4uLiqqgr&#43;988RsojNDzx3cBIWFvbgwYMXL16MHj1aLNFPOeEavsLS0lJfXx/&#43;9082d/wkmgAAuLm5vXz5Eo/Hjxgx4v79&#43;9LsGtGE/GJgYJCVleXj4&#43;Pt7b1r1y6p9fvT3OyAEWe&#43;cnmAQCCcPn3azs5u8&#43;bN79&#43;/P3bsGIFAkGiPrJ8lZBEb&#43;dIEn55OMPn5&#43;VeuXDEyMgoKCuIMcQS/gwwZMmT27Nmenp5XrlwRS9zkvmhoaPg5Qhb9D1kvcv8H/55OLP4S9RQXF1tbW&#43;vr60v0JKKwsBAA8ObNG8l1IWXEcC4qLiIiIvz9/V1cXKqrqyMiIpKTkzdu3MjV0a2goMDFxaW4uFhXVxcAMGnSJDMzs8OHD/eu2dzcPGfOnIyMjLi4ODhaoyh0d3e/ffsWPv79&#43;vVre3s7jUZDo9GfPn2aMmXKsGHDhgwZ8gMFW&#43;oTWYvy/&#43;Df04klYKIe0R3BGxsbjx49OnnyZDgGHA6Hs7a29vT0/OWXX/z9/SdNmjRmzBg4tDsAwNTUdNGiRRkZGeKNvClN5EUTveHh6aStrR0YGMj&#43;CF8GSUhI4NHauXPnFBQUvL29Gxoa&#43;LehoKBg3rx5BAKBQCDMnDnz8OHDHz586OtOQ0tLy8OHD6OiouA4PoaGhrt27Wpubua/OzlBTjXBYDAUFRW5RoOHzyCWL1/OLoGPqrds2cK7zby8PCMjIz4dwauqqgIDA1EolI2NzdGjRwXNE1xYWLh&#43;/XoSiaSmpvbXX39JP/2iKMipJlJTU52dnbn6cz948AAAsHXrVnbJx48fAQDz5s3rt9nq6moXFxdlZeWrV6/2VYfJZB44cEBZWdnc3Pzy5cuiTAH19fVbtmwhEAj29vYvX74Uuh0pI4&#43;a4O3pBO9Rbt&#43;&#43;nV0Cn5VHRkby0ziNRluwYAEEQVFRUb019/3796lTp2IwmK1btwqUYJgHpaWlXl5eeDweDhUnljYlijxqgrenExy&#43;c&#43;3ateyS3NxcAMCZM2f47yI&#43;Ph6LxQYEBHA6gn/&#43;/NnKysrAwEDsIQOYTGZsbCwWi503b578zyNyp4nY2NjExEQeFTo7O8lk8uzZs9klcPDGvLw8gTp69OiRpqbmsGHDYJ&#43;5oqIifX39oUOHfvnyRSjD&#43;&#43;fGjRsKCgp&#43;fn6ScBkUI/KliYSEhP3797M/MplMrjdHxJWop7S01M7OTkND49KlS8bGxi4uLgK9lQhBVlaWkpJSSEiIPE8icqSJI0eOuLq6JiYmJiYmnjhx4sCBA76&#43;vvAwfv/&#43;/cDAQHYe4srKSh0dHfhRS0uLlpZWfHy8cJ02NzdPnjxZTU3N1taWnzzHonP37l0cDhcVFSWFvoRDXjQhqKdTbm6up6fn7t27g4KCYmNjRel6wYIFZDJZml7XcXFxKBQqPT1daj0KhLxogjeSS9STmpoKQZAU7ij3IDAwUFdXV9BtD&#43;nwY2hCQrS1tZmYmISEhEi/6/r6ek1NzfDwcOl33S8DWhPbtm1TVVX9&#43;vWrTHpPSEhAo9FyGBZt4GqitbVVQ0ODdyZSicJgMGxtbUNDQ2VlQF8MXE3ExsYqKytL512jL06dOoXFYtn&#43;33LCT&#43;WPKRCJiYmBgYFkMlmGNgQGBpJIJNmGNu/NANXEu3fv3rx5ExISIlszcDjcr7/&#43;KkpmDEkwQDVx7949LS0tNzc3WRsCpk&#43;f/u7du5qaGlkb8j8GqCYePHjg4eHBI&#43;QIlUpdsmQJBEGurq498hM0NjbOmzfPzc2tqqqqqalp0aJFEARBEHT37l3OapWVlSQSyd3dHT7K74vRo0fj8Xg4vZK8IOsFjWzQ1NTkPFjpCzhrYe9Xg7Nnz7JdeLq7u0ePHg0A6HF0V1paOmjQIH52pZydneVqo2IgjhP19fV1dXX8xNRSVFR0dXU9efJkbGwsZzkOh2PfHkCj0YmJiQoKClu3bm1paWHX&#43;X//7/8dP35cRUWl316srKy45u&#43;UFQNRE/Bgbm5uzk/llJQUAwODdevWZWRk9FXH3Nx8&#43;/btlZWVsDMwACA9PR2DwfAZTN7S0rK0tJSfmtJhIGqisbERAKCmpsZPZR0dnatXr&#43;JwuICAAB4rg9WrVzs7O8fFxWVlZbW3t0dFRe3Zs4dPe9TU1JqamvisLAUGoiZaW1sBAJxXx3jj5OSUkJBQX18/bdo0ztmBEzQanZCQgMViFy1atHHjxlWrVvG/86GsrNzc3MxnZSkwEDUhBLNnz964ceOHDx/gOCRc69ja2v7nP/8pKSkpKioKDAzkv3EWiyVXKTMHoibgEQIeLfhnx44dU6ZMuX79&#43;tatW/uq4&#43;PjAwAYMmSIQC23tLTAt4nkhIGoCTj5Q0NDg0DfQqFQSUlJgwcPjo6OvnTpkhjtaWhokKtkMANRE/AbB4VCEfSLJBLp&#43;vXrampqfWmir2mFNyUlJXy&#43;BEmHgagJNTU1LS0t3nEOYaqrq9vb2zlLzM3NL168iEajudb/&#43;vUrAKCvdWhfFBcXw5tjcsJA1AQAYMSIEdnZ2Twq5OfnL168uLa2NjQ0tMfOhJeX1969e3t/5eTJk//5z38AAFeuXPnzzz&#43;/fPnCjyXt7e2vX7&#43;Gr5jKCzLeR5URe/fu1dDQEMWXk2vECyG4c&#43;cOBEE1NTViaU0sDNBxwtvb&#43;9u3b1lZWUK3IK68aKmpqUOHDoUDacgJA1QTNjY2Dg4OZ86cka0ZNBrt4sWLc&#43;fOla0ZPRigmgAAzJ8//8KFC9&#43;/f5ehDefPn29rawsKCpKhDb0ZuJpYsGABkUg8cOCArAxgMBgxMTEhISFyNXEAMFDXmDDR0dEkEklW67ujR49iMBgh8uxJmgGtCThFWVBQkPS7/v79u4aGBmfEBPlhQGuCxWLduHEDgqDLly9Lud&#43;ZM2fq6&#43;vLZ7Srga4JFov122&#43;/qaqq9pvpVIwcOHAAjUZnZmZKrUeBQDTB6ujocHR0tLKyEtc2FG9u3ryJwWCio6Ol0JdwIJpgsVismpoaU1PTESNGSPpaWGZmJpFIXLhwIRKT5AeAQqEYGRnZ2tpK7qbelStXCATCr7/&#43;KuchrRBN/I&#43;ampohQ4ZoaWndu3dPvC13d3dHRUWh0ejly5fLf3xdRBP/orGxcdasWWg0OjIyUly50QsKCsaOHUsgEI4cOSKWBiUNogkuxMXFqaqqGhsbJyUlCReiG4ZKpa5fvx6Hwzk6Oubn54vRQomCaII7X79&#43;DQ0NRaPRFhYWhw4dEnTt&#43;fbt2/DwcCKRqK6ufvDgQVGEJX0QTfCCQqEsWrRIUVERh8NNnjw5NjY2Pz&#43;/s7OTa&#43;X6&#43;vq0tLSNGzfCPrqmpqYaGhorV66Uss2iI0f5O&#43;SW1tbWlJSUa9euPXz4sL6&#43;Ho1Gm5iY6OjoKCkpKSoqNjc3NzY2lpeXw8Hh4TQOAQEBo0eP/vvvv6Oioj5//iwuZwvpgGhCAJhMZkFBQWFhYUlJCZVKbWtra2trI5FIJBLJ0NDQ2trazs5OT0&#43;PXb&#43;trc3Y2Dg8PBz2yftRQDQhWbZs2RIXF1deXq6oqChrW/hl4PpPSIdVq1a1t7dzjQgrtyDjhMRZvnz57du3KRQKBtNnlsaSkpLnz5/D/0ahUAEBAX1dF&#43;grW6I4ke0SdyDw6dMnDAaTlJTEo467uzv7N&#43;Lr69tXNX6yJYoOMk5Ig9mzZxcUFLx&#43;/ZrrXeHHjx9funRp4cKF8Ed9fX2uWY35z5YoKpIQGkIPYDXcvn2b61Nvb29&#43;/P8EypYoCsgaUxoMHTp04sSJXFOoZ2dn371719raeubMmS9evODRSF5enqWlJfujiYkJnU5PT08Xu7WIJqREZGTko0ePnj171qO8vr4&#43;MDDQ0NAwNTV11KhRf/31F9evf/v2rba2Vl1dnV1iYmICACgrKxO/rWIfeRD6wtXVdcaMGX09vXXrFvwrT0tL6/1UlGyJgoKME9Jj3bp1V69eLSgo4PrU19c3Pz&#43;fRCIdPHiw91MWiwUAgDO5w3R0dAAAdHR0xG4nognpMX36dGtra6530mEMDQ2nT5/ONS4inPuaM45KW1sbAMDOzk7sdiKakB4oFGrt2rVnzpypqKjoq463tzfXWBQmJiZkMpkzfkF5eTkAwNbWVvx2ir1FBB4EBwdramryuJBYUFDg5&#43;fXuxyHwwUFBXFehH/79q2mpqaNjY34rRT7CgWBN7t371ZUVPz27RuLxWIwGOvWrbt&#43;/TrspJmZmcl5KU1y2RJ5g2hC2jQ3N6uqqsL3OxgMBryrraenN3369J07d3J6ZEk0WyIPEE3IgE2bNmlpabW3t8Mfa2pquF4gkFy2RN4g5x0ygEqlmpiY7N27d&#43;nSpbK2hQuIJmTD0qVL7927V1JSwuMAXVYg7x2yYf369ZWVlZcvX5a1IVxAxgmZERAQUFxcnJ&#43;fL1fBtgEyTsiQzZs3v337Ni0tTdaG9AQZJ2TJxIkTu7u74fMt&#43;QEZJ2RJZGRkZmZmTk6OrA35F8g4IWNcXV319fXlarGJjBMyJiIiIjU1tbCwUNaG/A9knJAxTCbT2tra3d392LFjsrbl/0DGCRmDQqHWrVt35swZ&#43;UlFjGhC9sybN09dXb1HClMZgmhC9uDx&#43;FWrVsXFxcFJLmUOogm5YOnSpWg0&#43;siRI7I2BABEE3ICiURasmRJbGws7HkrWxBNyAtr1qxpbm4&#43;ffq0rA1B3kXlibCwsPv37xcXF8v2AB0ZJ&#43;SIyMjI8vLylJQU2ZqBjBPyhb&#43;/P4VCke0BOjJOyBeRkZFv3rzpkb1SyiDjhNzh5eUFAJChLJBxQu6IjIy8f/9&#43;bm6urAxAxgl5ZPjw4YMGDbp48aJMekc0IY8kJycHBQUVFRVZWFjAJUVFRQ8fPnz79m1JSUl5eXlra2tnZycEQaqqqurq6paWljY2NqNHj3Z2dsbj8SL2jmhCHmEwGIMHD/bw8Fi&#43;fPmpU6eSk5Orq6uVlZUdHBwsLS1NTU2VlJQIBAKTyWxqaqJSqUVFRR8&#43;fCgvLycSid7e3iEhIb6&#43;vpyBCQRDcteJEERh27Zt9vb2AIBBgwZt3br12bNn/WaC&#43;fTp07Fjx8aPH49CoQwMDPbt29fa2ipE14gm5I6ioiJPT08AwMSJE&#43;/fvy9Elqjy8vI1a9YoKirq6elduHBB0K8jmpAjmEzmrl278Hi8g4NDdna2iK1RqdRFixahUChfX18qlcr/FxFNyAv19fU&#43;Pj5YLHb37t1izPeRnZ1tamqqp6f35MkTPr&#43;CaEIuqKqqsrOzMzQ0zMnJEXvjDQ0N06ZNIxAIqamp/NRHNCF7qqqqTE1NBw8eLIkAqDAMBgN22&#43;FneSF3l5oHGg0NDd7e3goKCo8ePZJc6hcUCnX48GE8Hh8SEkImkydMmMCrtoSEicAPDAZj0qRJRkZGlZWVUuiOyWTOnTtXRUWFdyJuRBOyZOfOnTgcjjM6kaTp6OhwcHAYPnx4X1nNWIgmZEhBQQEOh/vrr7&#43;k3G9JSYmSktL27dv7qoBoQjYwmcxx48Y5OTnJJM3krl27FBQUPn36xPUpognZcPv2bQiCJPHmyQ90Ot3KyiokJITrU&#43;QMTDaMGTOGRCLdunVLVgacPn16wYIFRUVF5ubmPZ9JV6AILBaL9erVKwDAo0ePZGhDV1eXiYlJRERE70eIn5UMOHXqlIWFxZgxY2RoAwaDmTdv3tmzZ7u7u3s8QjQhbVgsVnJyckhIiMxDmwUHB9fW1j569KhHObKPKW3ev39fW1vr6&#43;vLo052djZnAh8MBqOiokImk&#43;3t7YlEItevVFdXX7p0iUKhqKurjxs3ztXVtaKigsFg8AjSbmZmZmlp&#43;eDBA/hong0yTkibhw8fqqmpDRs2jEedUaNGaWpqhoSErFy5kkKh0Gi0/Pz8mJgYdXV1X1/foqKiHvV37tzp4uLS2dkZFhYWHh7e1dXl4&#43;MzZsyYkpIS3sZ4enpyibAm9cXNQGfhwoWenp781CSTyVZWVpwlGRkZOjo6BAKB8yV23759WCy2x1F4R0eHs7PziRMneHdx/PhxRUXFHm47yDghbYqLi7lmbekNDofrUeLp6ZmQkECj0WbOnNnZ2QkAOH/&#43;/Jo1a7Zv3&#43;7m5sZZk0AgHDx4sL6&#43;nncXVlZWbW1t1dXVnIWIJqRNRUUFnPJPOHx9fT09PeHVAwAgOjoaLuxdc8SIEf2&#43;2piamgIAPn/&#43;zFmIaELatLS0kEgkUVpwdXUFAGRmZpaWlhYUFGAwmL4GnpEjR/JuCraktbWVsxDRhLRpb29XVFQUpQU482xlZSX8921ubt57luETJSUlCIJaWlo4CxFNSBssFkun00VpAc4YqKmpKXqYCjqdzmKxelwTQjQhbZSUlHqM1YICJ5u0sbGBb4lRKBShIx7BI4SysjJnIaIJaaOpqVlbWyv01&#43;l0&#43;s2bNzEYzIwZM/T19W1tbRkMxvv377lWZvV3wPn161fYJM5CRBPSxtLSkmtWWT7Zs2dPaWnp6tWr4Q3KP/74AwCwYcOG3vNRXV1dYmIi79aKi4tRKFTPo1F&#43;Nk8QxMiWLVt67ERxhU6no9Fozpo0Gm316tVYLHbTpk00Go1dHh0dDUFQSEgI503A8vLytWvXwssFHvzxxx9mZmY9CpHzDmnj5ua2Y8eOL1&#43;&#43;6Orq9lUnKytr//79DAbj48ePjo6OJiYmKBSqs7PTwMAgJyfH0dGRs/Lvv/9ubW29bds2TU3NkSNH2tnZ0el0fX39nTt39nuN&#43;OHDh6NHj&#43;5Zype2EcRHa2srFos9e/asJFp&#43;9uxZXV0dn/Xb2toIBMLJkyd7lCN&#43;VjLAx8cHg8HcuHFDtmacO3cuNDS0uroaWWPKnpCQkLt374ry9iEWzpw5M2nSpB6CAIgmZML06dPV1NQOHjwoQxvev39/7969xYsXc3km5jkNgT927Nihqqra2NgoKwMCAwPt7e25BrdANCEbGhsbNTQ0wsPDZdL706dPUSjU5cuXuT5FNCEzEhISMBhMXl6elPvt6uoaNmzYhAkT&#43;qqAaEJmMJlMd3d3a2tr4aJOCc2GDRuIRGJxcXFfFRBNyJKqqioNDY2goCAhglYJx7Vr1yAISkxM5FEH0YSMSUtLw2KxGzZskEJf2dnZRCIxLCyMdzVEE7LnzJkzEARt3bpVor08ffpUTU1t6tSp/cZURDQhFxw/fhyNRv/222/9/sKE4/r160QicerUqe3t7f1WRjQhL1y9elVRUXHUqFHl5eVibLarq2vjxo0QBC1evJhPwSGakCM&#43;fPhga2urqqp66NAhscSlgA9RiURiQkIC/99CNCFftLW1bdy4EYfDDR069MqVKwwGQ7h2CgoK5s6di0KhPDw8CgsLBfouogl5pLCwcObMmSgUytraeteuXVVVVXx&#43;saOjIzk5ecqUKSgUysbGJjk5WYjekbNy&#43;aWgoODQoUPJycmNjY329vbjx48fPny4lZWVsbGxqqoq7LTNjsv//v37hw8fPnnypLOzc8KECYsXL54&#43;fToKJcwZJ6IJeaezszMjIyMjI&#43;Phw4cFBQVsv0sMBsMZOsLQ0HD06NHjx4&#43;fMmWKjo6OKD0imviR6O7uLisrq6ioaG5ubm9vx&#43;FwKioq6urqVlZWSkpK4uoF0QRCTxCfGoSeIJpA6AmiCYSe/H94sAK3JnIHewAAAABJRU5ErkJggg&#61;&#61; " alt="" /></div>
<p>TLDR: Even though Haskell&#39;s <code>Map</code> and <code>Set</code> are <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span><sup id="fnref:1"><a href="#fndef:1" class="fnref">[1]</a></sup>, I was able still get Dijkstra&#39;s in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo><mi>log</mi><mo>⁡</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((V + E)\log V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">((</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span>. I used the <a href="https://hackage.haskell.org/package/PSQueue-1.2.0/docs/Data-PSQueue.html#t:Binding">PSQueue</a> library for my priority queue.</p>
<p>Let&#39;s first recall the structure of Dijkstra&#39;s algorithm. I&#39;ve included pseudo code below with asymptotic analysis for each line. The idea is we have a frontier &#40;<code>Q</code>&#41; that keeps track of what we think the shortest path is, and we update it as we remove the closest city &#40;and add it&#39;s neighbors&#41;. Dijkstra&#39;s overall runtime is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo><mi>log</mi><mo>⁡</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((V + E) \log V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">((</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span> or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>V</mi><mi>log</mi><mo>⁡</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V \log V + E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span> using Fibonacci heaps.</p>
<p>We need a visited set so we don&#39;t re-explore cities that we&#39;ve already gone to.</p>
<pre><code class="julia hljs">dijkstras(s,G)
     Q = Heap()                                          O(<span class="hljs-number">1</span>)
     visited = set()                                     O(<span class="hljs-number">1</span>)
     weights = map()                                     O(<span class="hljs-number">1</span>)

     Q.put(s, <span class="hljs-number">0</span>)
     <span class="hljs-keyword">while</span> !Q.empty                                      O(V)
             n,w = Q.pop_min()                           O(V * log V)
             weights[n] = w                              O(V * <span class="hljs-number">1</span>)
             visited.add(n)                              O(V * <span class="hljs-number">1</span>)
             <span class="hljs-keyword">for</span> (w_m, m) <span class="hljs-keyword">in</span> neighbors of n <span class="hljs-keyword">in</span> G         O(E)
                     <span class="hljs-keyword">if</span> m visited: skip                  O(E * <span class="hljs-number">1</span>)
                     Q.insert_or_decrease(m, w + w_m)    O(E * log V) O(E)</code></pre>
<p>So now, the question is, can this be done in the same time complexity, and the answer is yes<sup id="fnref:1"><a href="#fndef:1" class="fnref">[1]</a></sup>. I wrote two haskell functions, <code>dijkstras</code> which does the outside loop of taking a vertex off the queue, updating the frontier, the map of weights that we&#39;ll return, and the visited set. To update the frontier, we need to loop through all the edges connected to the vertex we just popped off. I made a function specifically for that which checks for containment in the visited set, and will either insert or decrease the priority of the node. Here&#39;s the code, with asymptotic analysis on the side. Anything with an exclamation point is asymptotically faster in the imperative version, but the overall runtime turns out to be the same.</p>
<pre><code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Node</span> = <span class="hljs-type">String</span></span>
<span class="hljs-comment">-- adjacency list</span>
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Graph</span> = <span class="hljs-type">Map</span>.<span class="hljs-type">Map</span> <span class="hljs-type">Node</span> [(<span class="hljs-type">Float</span>, <span class="hljs-type">Node</span>)]</span>

<span class="hljs-title">dijkstras</span> :: <span class="hljs-type">Graph</span> -&gt; <span class="hljs-type">Node</span> -&gt; <span class="hljs-type">Map</span>.<span class="hljs-type">Map</span> <span class="hljs-type">Node</span> <span class="hljs-type">Float</span>
<span class="hljs-title">dijkstras</span> graph start = dijkstras_helper <span class="hljs-type">Set</span>.empty (<span class="hljs-type">PSQ</span>.singleton start <span class="hljs-number">0</span>) <span class="hljs-type">Map</span>.empty
  <span class="hljs-keyword">where</span>
    dijkstras_helper visited frontier weights = 
      <span class="hljs-keyword">case</span> <span class="hljs-type">PSQ</span>.minView frontier <span class="hljs-keyword">of</span>                         <span class="hljs-comment">-- O(V)</span>
        <span class="hljs-type">Nothing</span> -&gt; weights                                 <span class="hljs-comment">-- O(V * 1 / V)</span>
        <span class="hljs-type">Just</span> (binding, frontier&#x27;) -&gt; <span class="hljs-keyword">let</span>                   <span class="hljs-comment">-- O(V * 1)</span>
            node = <span class="hljs-type">PSQ</span>.key binding                         <span class="hljs-comment">-- O(V * 1)</span>
            w = <span class="hljs-type">PSQ</span>.prio binding                           <span class="hljs-comment">-- O(V * 1)</span>
            edges = fromJust $ <span class="hljs-type">Map</span>.lookup node graph       <span class="hljs-comment">-- O(V * log V)!</span>
            visited&#x27; = <span class="hljs-type">Set</span>.insert node visited             <span class="hljs-comment">-- O(V * log V)!</span>
            weights&#x27; = <span class="hljs-type">Map</span>.insert node w weights           <span class="hljs-comment">-- O(V * log V)!</span>
            frontier&#x27;&#x27; = foldr (update_keys visited&#x27; w) frontier&#x27; edges <span class="hljs-comment">-- O(E * log V)</span>
            <span class="hljs-keyword">in</span>
            dijkstras_helper visited&#x27; frontier&#x27;&#x27; weights&#x27;   <span class="hljs-comment">-- O(V * 1)</span>

<span class="hljs-comment">-- acts as the inner loop of dijkstras, goes through the adjacent nodes and updates the frontier</span>
<span class="hljs-title">update_keys</span> :: <span class="hljs-type">Set</span>.<span class="hljs-type">Set</span> <span class="hljs-type">Node</span> -&gt; <span class="hljs-type">Float</span> -&gt; (<span class="hljs-type">Float</span>, <span class="hljs-type">Node</span>) -&gt; <span class="hljs-type">PSQ</span>.<span class="hljs-type">PSQ</span> <span class="hljs-type">Node</span> <span class="hljs-type">Float</span> -&gt; <span class="hljs-type">PSQ</span>.<span class="hljs-type">PSQ</span> <span class="hljs-type">Node</span> <span class="hljs-type">Float</span>
<span class="hljs-title">update_keys</span> visited w_0 (w, node) acc = 
  <span class="hljs-keyword">if</span> <span class="hljs-type">Set</span>.member node visited                               <span class="hljs-comment">-- O(log V)!</span>
  <span class="hljs-keyword">then</span> acc                                                 <span class="hljs-comment">-- O(1)</span>
  <span class="hljs-keyword">else</span> 
    <span class="hljs-keyword">case</span> <span class="hljs-type">PSQ</span>.lookup node acc <span class="hljs-keyword">of</span>                            <span class="hljs-comment">-- O(log V)!</span>
      <span class="hljs-type">Nothing</span> -&gt; <span class="hljs-type">PSQ</span>.insert node (w + w_0) acc             <span class="hljs-comment">-- O(log V)</span>
      <span class="hljs-type">Just</span> p -&gt; <span class="hljs-type">PSQ</span>.adjust (\_ -&gt; min p (w + w_0)) node acc<span class="hljs-comment">-- O(log V)</span>

<span class="hljs-title">the_us</span> :: <span class="hljs-type">Graph</span>
<span class="hljs-title">the_us</span> = <span class="hljs-type">Map</span>.fromList [
    (<span class="hljs-string">&quot;Prov&quot;</span>, [(<span class="hljs-number">2.0</span>, <span class="hljs-string">&quot;NY&quot;</span>), (<span class="hljs-number">1.0</span>, <span class="hljs-string">&quot;Boston&quot;</span>), (<span class="hljs-number">3.0</span>, <span class="hljs-string">&quot;Chester&quot;</span>)]), 
    (<span class="hljs-string">&quot;NY&quot;</span>, [(<span class="hljs-number">2.7</span>, <span class="hljs-string">&quot;Boston&quot;</span>), (<span class="hljs-number">2.0</span>, <span class="hljs-string">&quot;Prov&quot;</span>), (<span class="hljs-number">5.0</span>, <span class="hljs-string">&quot;DC&quot;</span>)]), 
    (<span class="hljs-string">&quot;Boston&quot;</span>, [(<span class="hljs-number">1.0</span>, <span class="hljs-string">&quot;Prov&quot;</span>), (<span class="hljs-number">2.5</span>, <span class="hljs-string">&quot;Chester&quot;</span>)]),
    (<span class="hljs-string">&quot;DC&quot;</span>, [(<span class="hljs-number">5.0</span>, <span class="hljs-string">&quot;NY&quot;</span>)]),
    (<span class="hljs-string">&quot;Chester&quot;</span>, [(<span class="hljs-number">3.0</span>, <span class="hljs-string">&quot;Prov&quot;</span>), (<span class="hljs-number">2.5</span>, <span class="hljs-string">&quot;Boston&quot;</span>)])
    ]

<span class="hljs-title">main</span> :: <span class="hljs-type">IO</span> ()
<span class="hljs-title">main</span> = <span class="hljs-keyword">do</span> 
    putStrLn <span class="hljs-string">&quot;Map of the US:&quot;</span>
    putStrLn $ show $ dijkstras the_us <span class="hljs-string">&quot;Prov&quot;</span></code></pre>
<table class="fndef" id="fndef:1">
    <tr>
        <td class="fndef-backref"><a href="#fnref:1">[1]</a></td>
        <td class="fndef-content">Here are the docs with asymptotic runtimes: <a href="https://hackage.haskell.org/package/containers-0.7/docs/Data-Set.html">set</a> and <a href="https://hackage.haskell.org/package/containers-0.4.0.0/docs/Data-Map.html">map</a></td>
    </tr>
</table>

    <script src="https://utteranc.es/client.js"
        repo="jasoneveleth/blog"
        issue-term="pathname"
        label="Comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
    </script>

<div class="page-foot">
    © Jason Eveleth 2023 · Powered by Franklin.jl · Last modified: January 24, 2024
</div>
</div><!-- CONTENT ENDS HERE -->
  </main> <!-- end of id=main -->

  <!-- if we're in an iframe -->
  <script>
    if (window.self != window.top) {
      console.log("we're in an iframe!!!");
      document.querySelectorAll(".blog-nav").forEach(i => i.style.display = "none");
    }
  </script>

  <!-- <script src="/blog/libs/vela/metisMenu.min.js"></script> -->
  <!-- <script src="/blog/libs/vela/slideout.min.js"></script> -->
  
    



  
  
    <script src="/blog/libs/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();hljs.configure({tabReplace: '    '});</script>

  
  
</body>
</html>
